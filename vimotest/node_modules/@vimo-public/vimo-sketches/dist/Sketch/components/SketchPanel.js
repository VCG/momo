"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
require("./SketchPanel.css");
var _QueryBuilder = _interopRequireDefault(require("./QueryBuilder"));
var _CircleTwoTone = _interopRequireDefault(require("@mui/icons-material/CircleTwoTone"));
var _ArrowRightAlt = _interopRequireDefault(require("@mui/icons-material/ArrowRightAlt"));
var _Edit = _interopRequireDefault(require("@mui/icons-material/Edit"));
var _Delete = _interopRequireDefault(require("@mui/icons-material/Delete"));
var _Info = _interopRequireDefault(require("@mui/icons-material/Info"));
var _paper = _interopRequireDefault(require("paper"));
var _GlobalContext = require("../contexts/GlobalContext");
var _lodash = _interopRequireDefault(require("lodash"));
var _material = require("@mui/material");
var _reactFontawesome = require("@fortawesome/react-fontawesome");
var _freeSolidSvgIcons = require("@fortawesome/free-solid-svg-icons");
var _mui = require("@react-awesome-query-builder/mui");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var InitialConfig = _mui.MuiConfig;
delete InitialConfig["conjunctions"]["OR"];
InitialConfig["settings"]["showNot"] = false;
InitialConfig["settings"]["groupOperators"] = false;
InitialConfig["settings"]["canAddGroup"] = false;
InitialConfig["settings"]["canReorder"] = false;
InitialConfig["settings"]["renderSize"] = "small";
InitialConfig["settings"]["setOpOnChangeField"] = ["keep", "first"];
function SketchPanel(props) {
  var i = 0;
  var attributes = props.attributes;
  var sketchPanelId = "sketch-panel";
  var _useState = (0, _react.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    nodes = _useState2[0],
    setNodes = _useState2[1];
  var _useState3 = (0, _react.useState)([]),
    _useState4 = _slicedToArray(_useState3, 2),
    nodeLabels = _useState4[0],
    setNodeLabels = _useState4[1];
  var _useState5 = (0, _react.useState)([]),
    _useState6 = _slicedToArray(_useState5, 2),
    edges = _useState6[0],
    setEdges = _useState6[1];
  var _useState7 = (0, _react.useState)(null),
    _useState8 = _slicedToArray(_useState7, 2),
    importData = _useState8[0],
    setImportData = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState10 = _slicedToArray(_useState9, 2),
    nodeImportUpdate = _useState10[0],
    setNodeImportUpdate = _useState10[1];
  var _useState11 = (0, _react.useState)(false),
    _useState12 = _slicedToArray(_useState11, 2),
    edgeImportUpdate = _useState12[0],
    setEdgeImportUpdate = _useState12[1];
  // States are node (add nodes), edge (add edges), edit(change node/edge properties)
  var _useState13 = (0, _react.useState)("node"),
    _useState14 = _slicedToArray(_useState13, 2),
    mouseState = _useState14[0],
    setMouseState = _useState14[1];
  var _useState15 = (0, _react.useState)(false),
    _useState16 = _slicedToArray(_useState15, 2),
    showInfo = _useState16[0],
    setShowInfo = _useState16[1];
  var _useState17 = (0, _react.useState)("crosshair"),
    _useState18 = _slicedToArray(_useState17, 2),
    cursor = _useState18[0],
    setCursor = _useState18[1];
  var _useState19 = (0, _react.useState)(),
    _useState20 = _slicedToArray(_useState19, 2),
    pencil = _useState20[0],
    setPencil = _useState20[1];
  // Checks for mouse intersections
  var _useState21 = (0, _react.useState)(),
    _useState22 = _slicedToArray(_useState21, 2),
    testCircle = _useState22[0],
    setTestCircle = _useState22[1];
  // Edit properties with boolean query builder
  var _React$useState = _react.default.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    popperLocation = _React$useState2[0],
    setPopperLocation = _React$useState2[1];
  var _React$useState3 = _react.default.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    showPopper = _React$useState4[0],
    setShowPopper = _React$useState4[1];
  var circleRadius = 5;
  var currentPath;
  var currentNode;
  var currentSelection;
  var _useState23 = (0, _react.useState)({}),
    _useState24 = _slicedToArray(_useState23, 2),
    canvasDimension = _useState24[0],
    setCanvasDimension = _useState24[1];
  var _useState25 = (0, _react.useState)(null),
    _useState26 = _slicedToArray(_useState25, 2),
    NodeFields = _useState26[0],
    setNodeFields = _useState26[1];
  var _useState27 = (0, _react.useState)(null),
    _useState28 = _slicedToArray(_useState27, 2),
    EdgeFields = _useState28[0],
    setEdgeFields = _useState28[1];
  var _useState29 = (0, _react.useState)([]),
    _useState30 = _slicedToArray(_useState29, 2),
    neurons = _useState30[0],
    setNeurons = _useState30[1];

  // We track the overall motif in the global context
  var context = (0, _react.useContext)(_GlobalContext.AppContext);
  var calculateNewPosition = function calculateNewPosition(dimension, position) {
    var newX = canvasDimension.width / dimension.width * position[1];
    var newY = canvasDimension.height / dimension.height * position[2];
    return [Math.floor(newX), Math.floor(newY)];
  };
  var getPositionTransformedData = function getPositionTransformedData(data) {
    var newNodes = data.nodes.map(function (node) {
      var _calculateNewPosition = calculateNewPosition(data.dimension, node.position),
        _calculateNewPosition2 = _slicedToArray(_calculateNewPosition, 2),
        newX = _calculateNewPosition2[0],
        newY = _calculateNewPosition2[1];
      return _objectSpread(_objectSpread({}, node), {}, {
        position: ["Point", newX, newY]
      });
    });
    var newData = _objectSpread(_objectSpread({}, data), {}, {
      nodes: newNodes,
      dimension: canvasDimension
    });
    return newData;
  };
  var importMotif = function importMotif() {
    console.log("importing motif");
    clearSketch(); // clear sketch
    // import file using file picker
    var fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.onchange = function (e) {
      var file = e.target.files[0];
      // parse file to object
      var reader = new FileReader();
      reader.readAsText(file, "UTF-8");
      reader.onload = function (e) {
        var data = JSON.parse(e.target.result);
        var newData = getPositionTransformedData(data);
        setImportData(newData);
        setNodeImportUpdate(true);
      };
    };
    fileInput.click();
  };
  var exportMotif = function exportMotif() {
    console.log("exporting motif");
    console.log(nodes);
    console.log(edges);
    var out = getEncodedMotif(nodes, edges);
    // download out as JSON file
    var json = JSON.stringify(out);
    var blob = new Blob([json], {
      type: "application/json"
    });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = "motif.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  var clearSketch = function clearSketch() {
    var _paper$project, _paper$project$active, _paper$view;
    console.log("Clearing");
    _paper.default === null || _paper.default === void 0 ? void 0 : (_paper$project = _paper.default.project) === null || _paper$project === void 0 ? void 0 : (_paper$project$active = _paper$project.activeLayer) === null || _paper$project$active === void 0 ? void 0 : _paper$project$active.removeChildren();
    _paper.default === null || _paper.default === void 0 ? void 0 : (_paper$view = _paper.default.view) === null || _paper$view === void 0 ? void 0 : _paper$view.draw();
    // Remove all edges and nodes
    setNodes([]);
    setEdges([]);
  };
  var deleteSketchElement = function deleteSketchElement() {
    // edges
    if (context.selectedSketchElement && context.selectedSketchElement.type === "edge") {
      var _context$selectedSket;
      var newEdges = edges.filter(function (edge) {
        return edge.label !== context.selectedSketchElement.label;
      });
      context.selectedSketchElement.edgeLine.remove();
      context.selectedSketchElement.lineGroup.remove();
      (_context$selectedSket = context.selectedSketchElement.propertyLabel) === null || _context$selectedSket === void 0 ? void 0 : _context$selectedSket.remove();
      context.setSelectedSketchElement(null);
      setEdges(newEdges);
    }
    // nodes
    if (context.selectedSketchElement && context.selectedSketchElement.type === "node") {
      // find adjacent edges
      var nodeLabel = context.selectedSketchElement.label;
      var adjacentEdges = edges.filter(function (edge) {
        if (edge.fromNode.label === nodeLabel || edge.toNode.label === nodeLabel) {
          return edge;
        }
      });

      // delete edges from canvas
      adjacentEdges.map(function (edge) {
        var _edge$propertyLabel;
        edge.edgeLine.remove();
        edge.lineGroup.remove();
        (_edge$propertyLabel = edge.propertyLabel) === null || _edge$propertyLabel === void 0 ? void 0 : _edge$propertyLabel.remove();
      });

      // delete node from canvas
      var selectedNodeLabel = context.selectedSketchElement.label;
      context.selectedSketchElement.circle.remove();
      context.selectedSketchElement.circleGroup.remove();
      context.setSelectedSketchElement(null);

      // delete node and rename remaining nodes
      var newNodes = nodes.filter(function (node) {
        return node.label !== selectedNodeLabel;
      }).map(function (node, i) {
        return renameCircle(node.circle, i, node.properties, "tree" in node ? node.tree : null, node.label);
      });
      var getNewNode = function getNewNode(previousLabel) {
        return newNodes.find(function (node) {
          return node.previousLabel === previousLabel;
        });
      };

      // delete adjacent edges
      var _newEdges = edges.filter(function (edge) {
        return !adjacentEdges.includes(edge);
      }).map(function (edge) {
        var newFromNode = getNewNode(edge.fromNode.label);
        var newToNode = getNewNode(edge.toNode.label);
        var newNodeIndices = [_lodash.default.findLastIndex(newNodes, newFromNode), _lodash.default.findLastIndex(newNodes, newToNode)];
        return renameEdge(newFromNode, newToNode, newNodeIndices, edge);
      });

      // reset edges and nodes
      setEdges(_newEdges);
      setNodes(newNodes);
    }
  };
  var renameEdge = function renameEdge(fromNode, toNode, nodeIndices, edge) {
    var tree = "tree" in edge ? edge.tree : null;
    var edgeObj = _objectSpread({}, edge);
    edgeObj["fromNode"] = fromNode;
    edgeObj["toNode"] = toNode;
    edgeObj["indices"] = nodeIndices;
    // edgeObj["label"] = `${fromNode.label} -> ${toNode.label}`;
    edgeObj["label"] = [edgeObj.fromNode.label, edgeObj.toNode.label];
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    return edgeObj;
  };
  var renameCircle = function renameCircle(circle, index) {
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var previousLabel = arguments.length > 4 ? arguments[4] : undefined;
    // circle.fillColor = context.neuronColors[index];
    circle.fillColor = "#000000";
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 20
    });
    var letter = index;
    label.content = letter;
    var circleGroup = new _paper.default.Group([circle, label]);
    if (tree !== null) {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup,
        tree: _mui.Utils.loadTree(tree)
      };
    } else {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup
      };
    }
  };
  // MS
  var addCircle = function addCircle(point, node) {
    // add circle to paper
    var circle = new _paper.default.Path.Circle(point, circleRadius);
    circle.strokeColor = "#000000";
    circle.strokeWidth = 3;
    circle.fillColor = context.neuronColors[node.index];
    circle.opacity = 1.0;
    circle.position = point;
    placeCircle(circle, node.label, node.properties, "tree" in node ? node.tree : null);
  };
  // MS
  var placeCircle = function placeCircle(circle, letter) {
    var _currentPath;
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    circle.opacity = 1;
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath = currentPath) === null || _currentPath === void 0 ? void 0 : _currentPath.remove();
    currentPath = null;
    var circleGroup = new _paper.default.Group([circle, label]);
    if (tree !== null) {
      setNodes(function (nodes) {
        return [].concat(_toConsumableArray(nodes), [{
          circle: circle,
          label: letter,
          properties: properties,
          type: "node",
          circleGroup: circleGroup,
          tree: _mui.Utils.loadTree(tree)
        }]);
      });
    } else {
      setNodes(function (nodes) {
        return [].concat(_toConsumableArray(nodes), [{
          circle: circle,
          label: letter,
          properties: properties,
          type: "node",
          circleGroup: circleGroup
        }]);
      });
    }
  };

  // dont know yet MS
  var bindPencilEvents = function bindPencilEvents() {
    currentPath = null;
    pencil.onMouseMove = function (event) {
      var point = new _paper.default.Point(event.point);
      testCircle.position = point;
      if (mouseState === "node") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
        var color = numNodes <= context.neuronColors.length ? context.neuronColors[numNodes] : "#000000";
        // Create new Circle
        if (!currentPath) {
          currentPath = new _paper.default.Path();
          currentPath.strokeColor = color;
          currentPath.strokeWidth = 3;
          currentPath.opacity = 0.5;
          currentPath.add([point.x, point.y]);
          currentPath.add([point.x, point.y]);
        }
        // else {
        //   // Move existing circle
        //   // console.log(currentPath)
        //   currentPath.position = point;
        // }
        // Starting Point of Edge
        if (currentNode) {
          currentPath.segments[1].point = point;
        } //    Ending Point of Edge
        else {
          currentPath.segments[0].point = new _paper.default.Point([point.x, point.y - 10]);
          currentPath.segments[1].point = new _paper.default.Point([point.x, point.y + 10]);
        }
      } else if (mouseState === "move") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        if (!currentPath) {
          currentPath = new _paper.default.Path();
          currentPath.strokeColor = "#FF0000";
          currentPath.strokeWidth = 3;
          currentPath.opacity = 0.5;
          currentPath.add([point.x, point.y]);
          currentPath.add([point.x, point.y]);
        }
        var intersections = _lodash.default.findLastIndex(edges.map(function (e) {
          return !_lodash.default.isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        // Starting Point of Edge
        if (intersections === -1 && currentNode) {
          currentPath.segments[1].point = point;
        } //    Ending Point of Edge
        else if (intersections !== -1 && currentNode && !_lodash.default.isEqual(currentNode, nodes[intersections])) {
          currentPath.segments[0].point = currentPath.segments[0].point;
          currentPath.segments[1].point = point;
        } // Otherwise move the line glyph
        else {
          currentPath.segments[0].point = new _paper.default.Point([point.x, point.y]);
          currentPath.segments[1].point = new _paper.default.Point([point.x, point.y]);
        }
      } else if (mouseState === "edge") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        if (!currentPath) {
          currentPath = new _paper.default.Path();
          currentPath.strokeColor = "#00FF00";
          currentPath.strokeWidth = 3;
          currentPath.opacity = 0.5;
          currentPath.add([point.x - 10, point.y]);
          currentPath.add([point.x + 10, point.y]);
        }
        var _intersections = _lodash.default.findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Starting Point of Edge
        if (_intersections === -1 && currentNode) {
          currentPath.segments[0].point = currentNode.circle.getNearestPoint(point);
          currentPath.segments[1].point = point;
        } //    Ending Point of Edge
        else if (_intersections !== -1 && currentNode && !_lodash.default.isEqual(currentNode, nodes[_intersections])) {
          // currentPath.segments[0].point = currentNode.circle.getNearestPoint(
          //   nodes[intersections].circle.position
          // );
          // currentPath.segments[1].point = nodes[
          //   intersections
          // ].circle.getNearestPoint(currentNode.circle.position);
        } // Otherwise move the line glyph
        else {
          currentPath.segments[0].point = new _paper.default.Point([point.x - 10, point.y]);
          currentPath.segments[1].point = new _paper.default.Point([point.x + 10, point.y]);
        }
      } else if (mouseState === "edit") {
        // Check with intersections with nodes
        var _intersections2 = _lodash.default.findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Check with intersections with nodes
        if (_intersections2 !== -1) {
          currentSelection = nodes[_intersections2];
          return;
        }
        // Check with intersections with edges
        _intersections2 = _lodash.default.findLastIndex(edges.map(function (e) {
          return !_lodash.default.isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        if (_intersections2 !== -1) {
          currentSelection = edges[_intersections2];
          return;
        }
        currentSelection = null;
      }
    };
    pencil.onMouseDown = function (event) {
      var point = new _paper.default.Point(event.point);
      if (mouseState === "move") {
        var _currentPath2;
        var intersections = _lodash.default.findLastIndex(edges.map(function (e) {
          return !_lodash.default.isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        if (intersections !== -1 && !currentNode && currentPath) {
          var fromPosition = edges[intersections].fromNode.circle.position;
          var toPosition = edges[intersections].toNode.circle.position;

          // Calculate the midpoint
          var midpointX = (fromPosition.x + toPosition.x) / 2;
          var midpointY = (fromPosition.y + toPosition.y) / 2;
          currentPath.segments[0].position = new _paper.default.Point([midpointX, midpointY]);
          currentNode = edges[intersections];
          // currentPath.segments[0].position =
          //   point;
          return;
        } else if (currentPath && intersections !== -1) {
          if (!_lodash.default.isEqual(currentNode, edges[intersections])) {
            currentPath.segments[0].point = currentPath.segments[0].position;
            // currentPath.segments[1].point = point;
            var _fromPosition = edges[intersections].fromNode.circle.position;
            var _toPosition = edges[intersections].toNode.circle.position;

            // Calculate the midpoint
            var _midpointX = (_fromPosition.x + _toPosition.x) / 2;
            var _midpointY = (_fromPosition.y + _toPosition.y) / 2;
            currentPath.segments[1].point = new _paper.default.Point([_midpointX, _midpointY]);
            var edge = currentPath.clone();
            edge.opacity = 1;
            addEdge2(currentPath.segments[0].point, currentPath.segments[1].point, edge, currentNode.label, edges[intersections].label);
          }
        }
        (_currentPath2 = currentPath) === null || _currentPath2 === void 0 ? void 0 : _currentPath2.remove();
        currentNode = null;
        currentPath = null;
      } else if (mouseState === "node") {
        var _currentPath3;
        if (!currentPath) return;
        var _intersections3 = _lodash.default.findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        if (_intersections3 !== -1 && !currentNode && currentPath) {
          currentNode = nodes[_intersections3];
          currentPath.segments[0].position = currentNode.circle.getNearestPoint(point);
          return;
        } else if (!currentNode && currentPath) {
          currentPath.segments[0].position = point;
          currentNode = new _paper.default.Point([point.x, point.y]);
          // currentPath.segments[0].position =
          //   point;
          return;
        } else if (currentPath && _intersections3 !== -1) {
          if (!_lodash.default.isEqual(currentNode, nodes[_intersections3])) {
            var _currentNode$circle;
            console.log(((_currentNode$circle = currentNode.circle) === null || _currentNode$circle === void 0 ? void 0 : _currentNode$circle.getNearestPoint) == undefined);
            // If line intersects with two nodes, draw edge
            currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[_intersections3].circle.position);
            currentPath.segments[1].point = nodes[_intersections3].circle.getNearestPoint(currentNode.circle.position);
            var _edge = currentPath.clone();
            _edge.opacity = 1;
            addEdge(currentNode, nodes[_intersections3], _edge);
          }
        } else if (currentPath) {
          if (!_lodash.default.isEqual(currentNode, new _paper.default.Point([point.x, point.y]))) {
            var _currentNode$circle2;
            if (((_currentNode$circle2 = currentNode.circle) === null || _currentNode$circle2 === void 0 ? void 0 : _currentNode$circle2.getNearestPoint) == undefined) {
              currentPath.segments[0].point = currentPath.segments[0].position;
              // currentPath.segments[1].point = point;
              currentPath.segments[1].point = point;
              var _edge2 = currentPath.clone();
              _edge2.opacity = 1;
              addEdge3(currentPath.segments[0].point, currentPath.segments[1].point, _edge2);
            } else {
              console.log(currentNode.circle);
              currentPath.segments[0].point = currentNode.circle.getNearestPoint(point);
              currentPath.segments[1].point = point;
              var _edge3 = currentPath.clone();
              _edge3.opacity = 1;
              addEdge4(currentNode, currentPath.segments[1].point, _edge3);
            }
          }
        }
        (_currentPath3 = currentPath) === null || _currentPath3 === void 0 ? void 0 : _currentPath3.remove();
        currentNode = null;
        currentPath = null;
      } else if (mouseState === "edge") {
        var _currentPath4;
        var _intersections4 = _lodash.default.findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        if (_intersections4 !== -1 && !currentNode && currentPath) {
          currentNode = nodes[_intersections4];
          currentPath.segments[0].position = currentNode.circle.getNearestPoint(point);
          return;
        } else if (currentPath && _intersections4 !== -1) {
          if (!_lodash.default.isEqual(currentNode, nodes[_intersections4])) {
            // If line intersects with two nodes, draw edge
            currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[_intersections4].circle.position);
            currentPath.segments[1].point = nodes[_intersections4].circle.getNearestPoint(currentNode.circle.position);
            var _edge4 = currentPath.clone();
            _edge4.opacity = 1;
            addEdge(currentNode, nodes[_intersections4], _edge4);
          }
        }
        (_currentPath4 = currentPath) === null || _currentPath4 === void 0 ? void 0 : _currentPath4.remove();
        currentNode = null;
        currentPath = null;
      } else if (mouseState === "edit") {
        var nodeIntersections = _lodash.default.findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        var edgeIntersections = _lodash.default.findLastIndex(edges.map(function (e) {
          return !_lodash.default.isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        // select the clicked on element and show the popper
        if (nodeIntersections !== -1 || edgeIntersections !== -1) {
          var _currentSelection, _currentSelection2;
          context.setSelectedSketchElement(currentSelection);
          var selectedElement = ((_currentSelection = currentSelection) === null || _currentSelection === void 0 ? void 0 : _currentSelection.lineGroup) || ((_currentSelection2 = currentSelection) === null || _currentSelection2 === void 0 ? void 0 : _currentSelection2.circle);
          _paper.default.project.activeLayer.selected = false;
          selectedElement.selected = true;
          setShowPopper(true);
        } else {
          // If they click out, make the popper go away
          setShowPopper(false);
          context.setSelectedSketchElement(null);
          setPopperLocation(null);
        }
      }
      // else if (mouseState === "move") {
      //   let intersections = _.findLastIndex(
      //     nodes.map((n) => {
      //       return n.circle.contains(event.point);
      //     }),
      //     (e) => e === true
      //   );
      //   // Check with intersections with nodes
      //   if (intersections !== -1) {
      //     currentSelection = nodes[intersections];
      //   }
      //   if (currentSelection) {
      //     setCursor("grabbing");
      //   }
      // }
    };

    pencil.onMouseUp = function (event) {
      // if (mouseState === "move") {
      // console.log("grab", currentNode);

      // let nodeIndex = _.findLastIndex(
      //   nodes.map((n) => n.label === currentNode.label)
      // );
      // // // list of edges including this edge
      // let tmpEdges = _.clone(edges);
      // let edgesToAddAgain = [];
      // let filteredEdges = tmpEdges.filter((e) => {
      //   if (e.indices.includes(nodeIndex)) {
      //     edgesToAddAgain.push(e);
      //     return false;
      //   }
      //   return true;
      // });
      // let newEdges = edgesToAddAgain.map((e) => {
      //   e.edgeLine.opacity = 1;
      //   return createEdge(
      //     e.fromNode,
      //     e.toNode,
      //     e.edgeLine,
      //     e.indices,
      //     e.properties,
      //     e.tree,
      //     e.propertyLabel
      //   );
      // });

      // setEdges([...newEdges, ...filteredEdges]);

      // setCursor("grab");
      // }
    };
    pencil.onMouseDrag = function (event) {
      // if (mouseState === "move") {
      // nodeLabels.forEach((label) => {
      //   label?.remove();
      // });
      // let intersections = _.findLastIndex(
      //   nodes.map((n) => {
      //     return n.circle.contains(event.point);
      //   }),
      //   (e) => e === true
      // );
      // // Check with intersections with nodes
      // if (intersections === -1) return;
      // nodes[intersections].circleGroup.position = new paper.Point(
      //   event.point
      // );
      // currentNode = nodes[intersections];

      // edges.forEach((e, i) => {
      //   if (e.indices.includes(intersections)) {
      //     if (e.lineGroup) {
      //       edges[i].edgeLine.remove();
      //       edges[i].lineGroup.remove();
      //       edges[i].propertyLabel?.remove();
      //       edges[i].edgeLine = null;
      //       edges[i].edgeLine = null;
      //       edges[i].oppositeEdge = null;
      //       edges[i].edgeLine = new paper.Path();
      //       edges[i].edgeLine.strokeColor = "#000000";
      //       edges[i].edgeLine.strokeWidth = 3;
      //       edges[i].edgeLine.opacity = 0.5;
      //       edges[i].edgeLine.add([0, 0]);
      //       edges[i].edgeLine.add([0, 0]);
      //     }
      //     edges[i].edgeLine.segments[0].point = nodes[
      //       e.indices[0]
      //     ].circle.getNearestPoint(nodes[e.indices[1]].circle.position);
      //     edges[i].edgeLine.segments[1].point = nodes[
      //       e.indices[1]
      //     ].circle.getNearestPoint(nodes[e.indices[0]].circle.position);
      //   }
      // });
      // }
    };
  };
  // basics MS
  var addEdge = function addEdge(fromNode, toNode, edgeLine) {
    var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var tree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var addEdgeImmediately = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var nodeIndices = [_lodash.default.findLastIndex(nodes, fromNode), _lodash.default.findLastIndex(nodes, toNode)];
    var matchingEdge = _lodash.default.findIndex(edges, function (e) {
      return _lodash.default.isEqual(e.indices, nodeIndices);
    });
    if (matchingEdge !== -1) {
      console.log("Edge Exists");
      edgeLine.remove();
      return;
    }
    var newEdgeObj = createEdge(fromNode, toNode, edgeLine, nodeIndices, ["neuron connection"], tree);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([].concat(_toConsumableArray(edges), [newEdgeObj]));
    }
    return newEdgeObj;
  };
  var addEdge2 = function addEdge2(fromNode, toNode, edgeLine, con1label, con2label) {
    var _currentPath5, _currentPath6;
    var properties = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var tree = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var addEdgeImmediately = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
    var n1 = {};
    var n2 = {};
    currentPath = new _paper.default.Path.Circle(fromNode, circleRadius - 2);
    currentPath.strokeColor = "#000000";
    currentPath.strokeWidth = 3;
    currentPath.fillColor = "#000000";
    currentPath.opacity = 0.5;
    var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
    var letter = numNodes;
    var circle = currentPath.clone();

    // placeCircle(circle, letter);
    circle.opacity = 1;
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath5 = currentPath) === null || _currentPath5 === void 0 ? void 0 : _currentPath5.remove();
    currentPath = null;
    var circleGroup = new _paper.default.Group([circle, label]);
    n1 = {
      circle: circle,
      label: letter,
      properties: null,
      type: "node",
      circleGroup: circleGroup
    };
    setNodes(function (nodes) {
      return [].concat(_toConsumableArray(nodes), [n1]);
    });
    currentPath = new _paper.default.Path.Circle(toNode, circleRadius - 2);
    currentPath.strokeColor = "#000000";
    currentPath.strokeWidth = 3;
    currentPath.fillColor = "#000000";
    currentPath.opacity = 0.5;
    numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
    letter = numNodes + 1;
    circle = currentPath.clone();

    // placeCircle(circle, letter);
    circle.opacity = 1;
    textPoint = [circle.position.x, circle.position.y + 7];
    label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath6 = currentPath) === null || _currentPath6 === void 0 ? void 0 : _currentPath6.remove();
    currentPath = null;
    circleGroup = new _paper.default.Group([circle, label]);
    n2 = {
      circle: circle,
      label: letter,
      properties: null,
      type: "node",
      circleGroup: circleGroup
    };
    setNodes(function (nodes) {
      return [].concat(_toConsumableArray(nodes), [n2]);
    });
    // placeCircle(circle, letter);

    var nodeIndices = [nodes.length, nodes.length + 1];
    var newEdgeObj = createEdge(n1, n2, edgeLine, nodeIndices, ["synaptic connection", con1label, con2label], null);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([].concat(_toConsumableArray(edges), [newEdgeObj]));
    }
    return newEdgeObj;
  };
  var addEdge3 = function addEdge3(fromNode, toNode, edgeLine) {
    var _currentPath7, _currentPath8, _nodes$length;
    var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var tree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var addEdgeImmediately = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var n1 = {};
    var n2 = {};
    currentPath = new _paper.default.Path.Circle(fromNode, circleRadius);
    currentPath.strokeColor = "#000000";
    currentPath.strokeWidth = 3;
    currentPath.fillColor = "#000000";
    currentPath.opacity = 0.5;
    var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
    var letter = numNodes;
    var circle = currentPath.clone();

    // placeCircle(circle, letter);
    circle.opacity = 1;
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath7 = currentPath) === null || _currentPath7 === void 0 ? void 0 : _currentPath7.remove();
    currentPath = null;
    var circleGroup = new _paper.default.Group([circle, label]);
    n1 = {
      circle: circle,
      label: letter,
      properties: null,
      type: "node",
      circleGroup: circleGroup
    };
    setNodes(function (nodes) {
      return [].concat(_toConsumableArray(nodes), [n1]);
    });
    currentPath = new _paper.default.Path.Circle(toNode, circleRadius);
    currentPath.strokeColor = "#000000";
    currentPath.strokeWidth = 3;
    currentPath.fillColor = "#000000";
    currentPath.opacity = 0.5;
    numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
    letter = numNodes + 1;
    circle = currentPath.clone();

    // placeCircle(circle, letter);
    circle.opacity = 1;
    textPoint = [circle.position.x, circle.position.y + 7];
    label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath8 = currentPath) === null || _currentPath8 === void 0 ? void 0 : _currentPath8.remove();
    currentPath = null;
    circleGroup = new _paper.default.Group([circle, label]);
    n2 = {
      circle: circle,
      label: letter,
      properties: null,
      type: "node",
      circleGroup: circleGroup
    };
    setNodes(function (nodes) {
      return [].concat(_toConsumableArray(nodes), [n2]);
    });
    // placeCircle(circle, letter);

    var nodeLength = (_nodes$length = nodes.length) !== null && _nodes$length !== void 0 ? _nodes$length : 0; // If nodes.length is null or undefined, set it to 0

    var nodeIndices = [nodeLength, nodeLength + 1];
    var newEdgeObj = createEdge(n1, n2, edgeLine, nodeIndices, ["neuron connection"], tree);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([].concat(_toConsumableArray(edges), [newEdgeObj]));
    }
    return newEdgeObj;
  };
  var addEdge4 = function addEdge4(fromNode, toNode, edgeLine) {
    var _currentPath9;
    var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var tree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var addEdgeImmediately = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var n1 = {};
    var n2 = {};
    currentPath = new _paper.default.Path.Circle(toNode, circleRadius);
    currentPath.strokeColor = "#000000";
    currentPath.strokeWidth = 3;
    currentPath.fillColor = "#000000";
    currentPath.opacity = 0.5;
    var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
    var letter = numNodes;
    var circle = currentPath.clone();

    // placeCircle(circle, letter);
    circle.opacity = 1;
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 1
    });
    label.content = letter;
    (_currentPath9 = currentPath) === null || _currentPath9 === void 0 ? void 0 : _currentPath9.remove();
    currentPath = null;
    var circleGroup = new _paper.default.Group([circle, label]);
    n2 = {
      circle: circle,
      label: letter,
      properties: null,
      type: "node",
      circleGroup: circleGroup
    };
    setNodes(function (nodes) {
      return [].concat(_toConsumableArray(nodes), [n2]);
    });
    // placeCircle(circle, letter);

    var nodeIndices = [_lodash.default.findLastIndex(nodes, fromNode), nodes.length];
    var newEdgeObj = createEdge(fromNode, n2, edgeLine, nodeIndices, ["neuron connection"], tree);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([].concat(_toConsumableArray(edges), [newEdgeObj]));
    }
    return newEdgeObj;
  };
  var addExistEdges = function addExistEdges(newEdges) {
    var output = [];
    newEdges.map(function (edge) {
      var path = new _paper.default.Path();
      path.strokeColor = "#000000";
      path.strokeWidth = 3;
      path.opacity = 1.0;
      path.add([edge.fromNode.circle.position[1], edge.fromNode.circle.position[2]]);
      path.add([edge.toNode.circle.position[1], edge.toNode.circle.position[2]]);
      var startNode = nodes[edge.indices[0]];
      var endNode = nodes[edge.indices[1]];
      path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
      path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
      var tree = "tree" in edge ? edge.tree : null;
      var _newEdge = createEdge(startNode, endNode, path, edge.indices, edge.properties, tree);
      output.push(_newEdge);
    });
    setEdges([].concat(output));
  };
  var createEdge = function createEdge(fromNode, toNode, edgeLine, nodeIndices) {
    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var tree = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var propertyLabel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var edgeObj = {
      indices: nodeIndices,
      toNode: toNode,
      fromNode: fromNode,
      edgeLine: edgeLine
    };
    // If this edge already exists, don't create it
    // Checks from an edge going the opposite direction between the same two nodes
    var origToPoint = _lodash.default.cloneDeep(edgeLine.segments[0].point);
    var circ = new _paper.default.Path.Circle(origToPoint, 8);
    var toPoint = edgeLine.segments[0].point = circ.getIntersections(edgeLine)[0].point;
    circ.remove();
    var origFromPoint = _lodash.default.cloneDeep(edgeLine.segments[1].point);
    circ = new _paper.default.Path.Circle(origFromPoint, 8);
    var fromPoint = edgeLine.segments[1].point = circ.getIntersections(edgeLine)[0].point;
    var dy = toPoint.y - fromPoint.y;
    var dx = toPoint.x - fromPoint.x;
    var theta = Math.atan2(dy, dx); // range (-PI, PI]
    var newY = 7 * Math.sin(theta) + fromPoint.y;
    var newX = 7 * Math.cos(theta) + fromPoint.x;
    var circle = new _paper.default.Path.Circle([newX, newY], 7);
    // Check where the arrow head points should be
    var secondCircle = new _paper.default.Path.Circle(circle.getNearestPoint(toPoint), 7);
    var intersections = secondCircle.getIntersections(circle).map(function (intersection) {
      return intersection.point;
    });
    intersections.splice(1, 0, fromPoint);
    var trianglePath = new _paper.default.Path(intersections);
    trianglePath.strokeColor = "black";
    trianglePath.strokeWidth = 3;
    trianglePath.strokeJoin = "round";
    // Create a big group with line and arrow
    edgeObj["toPoint"] = toPoint;
    edgeObj["fromPoint"] = fromPoint;
    edgeObj["lineGroup"] = new _paper.default.Group([trianglePath, edgeObj.edgeLine]);
    secondCircle === null || secondCircle === void 0 ? void 0 : secondCircle.remove();
    circle === null || circle === void 0 ? void 0 : circle.remove();
    edgeObj["type"] = "edge";
    // edgeObj["label"] = `${edgeObj.fromNode.label} -> ${edgeObj.toNode.label}`;
    edgeObj["label"] = [edgeObj.fromNode.label, edgeObj.toNode.label];
    edgeObj["properties"] = properties;
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    if (propertyLabel) edgeObj = addEdgePropertyLabel(edgeObj);
    return edgeObj;
  };
  var addEdgePropertyLabel = function addEdgePropertyLabel(e) {
    var _e$propertyLabel;
    // Remove any existing label
    if (!e.properties) return e;
    (_e$propertyLabel = e.propertyLabel) === null || _e$propertyLabel === void 0 ? void 0 : _e$propertyLabel.remove();
    var midpoint = new _paper.default.Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
    var midpointCircle = new _paper.default.Path.Circle(midpoint, 10);
    var intersectionsCircles = midpointCircle.getIntersections(e.lineGroup.children[1]).map(function (i) {
      return new _paper.default.Path.Circle(i.point, 15);
    });
    var drawPoints = intersectionsCircles[0].getIntersections(intersectionsCircles[1]).map(function (i) {
      return i.point;
    });
    var topPoint = _lodash.default.sortBy(drawPoints, "y")[0];
    midpointCircle.remove();
    intersectionsCircles.map(function (i) {
      return i.remove();
    });
    var labelText = "";
    // if ("weight" in e.properties) {
    //   if (_.isNumber(e.properties.weight)) {
    //     labelText = e.properties.weight;
    //   } else if (e.properties.weight["$lt"]) {
    //     labelText = "< " + e.properties.weight["$lt"];
    //   } else if (e.properties.weight["$gt"]) {
    //     labelText = "> " + e.properties.weight["$gt"];
    //   }
    // }

    var propertyLabel = new _paper.default.PointText({
      point: topPoint,
      justification: "center",
      fillColor: "black",
      font: "Roboto",
      fontSize: 14
    });
    propertyLabel.content = labelText;
    e.propertyLabel = propertyLabel;
    return e;
  };
  (0, _react.useEffect)(function () {
    if (importData && nodeImportUpdate) {
      importData.nodes.forEach(function (node) {
        var point = new _paper.default.Point(node.position[1], node.position[2]);
        addCircle(point, node);
      });
      setNodeImportUpdate(false);
      setEdgeImportUpdate(true);
    }
  }, [nodeImportUpdate]);
  (0, _react.useEffect)(function () {
    if (importData && edgeImportUpdate) {
      var newEdges = [];
      try {
        importData.edges.forEach(function (edge) {
          var myInputStartNode = importData.nodes.find(function (node) {
            return node.index === edge.indices[0];
          });
          var myInputEndNode = importData.nodes.find(function (node) {
            return node.index === edge.indices[1];
          });
          var path = new _paper.default.Path();
          path.strokeColor = "#000000";
          path.strokeWidth = 3;
          path.opacity = 1.0;
          path.add([myInputStartNode.position[1], myInputStartNode.position[2]]);
          path.add([myInputEndNode.position[1], myInputEndNode.position[2]]);
          var startNode = nodes[edge.indices[0]];
          var endNode = nodes[edge.indices[1]];
          path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
          path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
          var tree = "tree" in edge ? edge.tree : null;
          var newEdge = addEdge(startNode, endNode, path, edge.properties, tree, false);
          newEdges.push(newEdge);
        });
        context.setErrorMessage(null);
        // context.setLoadingMessage(null);
      } catch (TypeError) {
        context.setErrorMessage("The motif can't import. Please try again in a larger window.");
        // context.setLoadingMessage(null);
        clearSketch();
      }

      // add new edges to edges
      setEdges([].concat(_toConsumableArray(edges), newEdges));
      setEdgeImportUpdate(false);
      setImportData(null);
    }
  }, [edgeImportUpdate]);

  // Checks for edges going opposite to each other and offsets them so they are distinguishable
  (0, _react.useEffect)(function () {
    if (!edges) return;
    edges.forEach(function (e, i) {
      var oppositeEdge = _lodash.default.findIndex(edges, function (oppE) {
        return _lodash.default.isEqual(oppE.indices, [e.indices[1], e.indices[0]]);
      });
      if (oppositeEdge !== -1 && !e.oppositeEdge && oppositeEdge > i) {
        var midpoint = new _paper.default.Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
        var circle1 = new _paper.default.Path.Circle(midpoint, 5);
        var circle2 = new _paper.default.Path.Circle(circle1.getIntersections(edges[oppositeEdge].edgeLine)[0].point, Math.sqrt(Math.pow(5, 2) + Math.pow(5, 2)));
        var pointDelta = circle2.getIntersections(circle1).map(function (e) {
          return e.point;
        }).sort(function (a, b) {
          return a.y - b.y;
        }).map(function (pt) {
          return new _paper.default.Point([midpoint.x - pt.x, midpoint.y - pt.y]);
        });
        e["lineGroup"].translate(pointDelta[0]);
        edges[oppositeEdge]["lineGroup"].translate(pointDelta[1]);
        edges[oppositeEdge]["oppositeEdge"] = i;
        e["oppositeEdge"] = oppositeEdge;
      }
      if (e.properties === undefined && e.propertyLabel) {
        e.propertyLabel.content = "";
      }
    });
  }, [edges]);
  (0, _react.useEffect)(function () {
    if (pencil && mouseState) {
      // Rebind the pencil events whenever new nodes are drawn
      bindPencilEvents();
    }
  }, [pencil, mouseState, nodes, edges]);
  (0, _react.useEffect)(function () {
    var _currentPath10, _paper$project2;
    (_currentPath10 = currentPath) === null || _currentPath10 === void 0 ? void 0 : _currentPath10.remove();
    setPopperLocation(null);
    setShowPopper(false);
    if (_paper.default !== null && _paper.default !== void 0 && (_paper$project2 = _paper.default.project) !== null && _paper$project2 !== void 0 && _paper$project2.activeLayer) {
      _paper.default.project.activeLayer.selected = false;
      // Remove all undrawn shapes when you switch modes
      _paper.default.project.activeLayer.children.forEach(function (child) {
        if (child.opacity === 0.5) child.remove();
      });
    }
  }, [mouseState]);
  (0, _react.useEffect)(function () {
    // if context.selectedSketchElement is not null
    if (context.selectedSketchElement) {
      var _context$selectedSket2, _context$selectedSket3;
      var paperElement = ((_context$selectedSket2 = context.selectedSketchElement) === null || _context$selectedSket2 === void 0 ? void 0 : _context$selectedSket2.circle) || (context === null || context === void 0 ? void 0 : (_context$selectedSket3 = context.selectedSketchElement) === null || _context$selectedSket3 === void 0 ? void 0 : _context$selectedSket3.edgeLine);
      // Calculate where on screen coordinates the popper should go
      var position = paperElement.getPosition();
      var boundingRect = _paper.default.view.element.getBoundingClientRect();
      if (paperElement && position) {
        setPopperLocation({
          top: position.y + boundingRect.top + 30,
          left: position.x + boundingRect.left - 30
        });
      }
      if (context.selectedSketchElement.type === "edge") {
        setEdges(edges.map(function (e) {
          // Update the edge with the query properties
          if (_lodash.default.isEqual(e.edgeLine, context.selectedSketchElement.edgeLine)) {
            e.tree = context.selectedSketchElement.tree;
            e.properties = context.selectedSketchElement.properties;
            e = addEdgePropertyLabel(e);
          }
          if (e.fromNode.label === context.selectedSketchElement.fromNode.label && e.toNode.label === context.selectedSketchElement.toNode.label) {
            e.edgeLine.strokeColor = "red";
            e.lineGroup.children[0].strokeColor = "red";
          } else {
            e.edgeLine.strokeColor = "#000000";
            e.lineGroup.children[0].strokeColor = "#000000";
          }
          return e;
        }));
      } else {
        setNodes(nodes.map(function (n) {
          if (_lodash.default.isEqual(n.circle, context.selectedSketchElement.circle)) {
            // Update the node with the query properties
            n.tree = context.selectedSketchElement.tree;
            n.properties = context.selectedSketchElement.properties;
          }
          return n;
        }));
      }
    } else {
      setPopperLocation(null);
      setEdges(edges.map(function (e) {
        e.edgeLine.strokeColor = "#000000";
        e.lineGroup.children[0].strokeColor = "#000000";
        return e;
      }));
    }
  }, [context.selectedSketchElement]);

  // On init set up our paperjs
  (0, _react.useEffect)(function () {
    _paper.default.setup(sketchPanelId);
    _paper.default.view.onResize = function () {
      setCanvasDimension(_paper.default.view.size);
    };
    setCanvasDimension(_paper.default.view.size);
    var tempCircle = new _paper.default.Path.Circle([0, 0], 6);
    tempCircle.fill = "none";
    tempCircle.strokeWidth = 0;
    setTestCircle(tempCircle);
    var tool = new _paper.default.Tool();
    if (!pencil) {
      setPencil(tool);
    }
    // fetch Node and Edge Fields
    if (!NodeFields || !EdgeFields) {
      if (typeof attributes !== "undefined") {
        setNodeFields(attributes.NodeFields);
        setEdgeFields(attributes.EdgeFields);
      }
    }
    if (nodes.length > 0) {
      var newNodes = _toConsumableArray(nodes);
      setNodes([]);
      newNodes.map(function (node) {
        placeCircle(node.circle, node.label, node.properties, node.tree);
      });
    }
    if (edges.length > 0) {
      var newEdges = _toConsumableArray(edges);
      addExistEdges(newEdges);
    }
    return function () {
      // cleanup component once destroyed
      tool.remove();
      tool.off("mousemove");
      tool.off("mousedown");
      tool.off("mouseup");
    };
  }, []);
  var getEncodedMotif = function getEncodedMotif(nodes, edges) {
    var encodedNodes = nodes.map(function (n, i) {
      return {
        label: n.label,
        properties: n.properties,
        index: i,
        position: n.circle.position,
        tree: n.tree
      };
    });
    var encodedEdges = edges.map(function (e, i) {
      return {
        label: e.label,
        properties: e.properties,
        index: i,
        indices: e.indices,
        tree: e.tree
      };
    });
    var sketchPanelDim = {
      width: canvasDimension.width,
      height: canvasDimension.height
    };
    return {
      nodes: encodedNodes,
      edges: encodedEdges,
      dimension: sketchPanelDim
    };
  };
  // Encode the Nodes and Edges For Query
  (0, _react.useEffect)(function () {
    var encodedMotif = getEncodedMotif(nodes, edges);
    context.setMotifQuery(encodedMotif);

    // most motif queries fail for n larger than 4, develop heuristics to make more accurate
    // nodes.length > 4
    //   ? context.setShowWarning(true)
    //   : context.setShowWarning(false);
    // if (
    //   typeof attributes != "undefined" &&
    //   attributes.getMotifCount &&
    //   attributes.getRelativeMotifCount
    // ) {
    //   const count = await attributes.getMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setAbsMotifCount(count);

    //   // get relative count of motif in network
    //   const relative_count = await attributes.getRelativeMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setRelativeMotifCount(relative_count);
    // }
  }, [nodes, edges]);
  var isObject = function isObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
  };
  var parsePropertyText = function parsePropertyText(key, value) {
    var parsedValue = "";
    if (isObject(value)) {
      if (value["$ne"]) {
        parsedValue = "Not ".concat(value["$ne"]);
      } else if (value["$lt"]) {
        parsedValue = "< " + value["$lt"];
      } else if (value["$gt"]) {
        parsedValue = "> " + value["$gt"];
      }
    } else {
      parsedValue = value;
    }
    return "".concat(key, ": ").concat(parsedValue, "\n");
  };
  (0, _react.useEffect)(function () {
    if (!nodes) return;
    nodeLabels.forEach(function (label) {
      label === null || label === void 0 ? void 0 : label.remove();
    });
    setNodeLabels(nodes.map(function (n) {
      if (!showInfo) return null;
      console.log("nodes", n, "show", showInfo);
      var propertiesText = _lodash.default.entries(n === null || n === void 0 ? void 0 : n.properties).map(function (p) {
        return parsePropertyText(p[0], p[1]);
      });
      var labelPoint = [n.circle.position.x, n.circle.position.y - circleRadius - 10 * propertiesText.length];
      var label = new _paper.default.PointText({
        point: labelPoint,
        justification: "center",
        fillColor: "black",
        font: "Roboto",
        fontSize: 10
      });
      label.content = propertiesText.join("");
      return label;
    }));
  }, [nodes, showInfo, edges]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "sketch-panel-style"
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "canvas-wrapper",
    spacing: 0
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Draw Node",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "node",
    color: mouseState === "node" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath11;
      (_currentPath11 = currentPath) === null || _currentPath11 === void 0 ? void 0 : _currentPath11.remove();
      setCursor("crosshair");
      setMouseState("node");
    }
  }, /*#__PURE__*/_react.default.createElement(_CircleTwoTone.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Draw Edge",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    color: mouseState === "edge" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath12;
      (_currentPath12 = currentPath) === null || _currentPath12 === void 0 ? void 0 : _currentPath12.remove();
      setCursor("crosshair");
      setMouseState("edge");
    }
  }, /*#__PURE__*/_react.default.createElement(_ArrowRightAlt.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Edit Properties",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "edit" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath13;
      setCursor("pointer");
      (_currentPath13 = currentPath) === null || _currentPath13 === void 0 ? void 0 : _currentPath13.remove();
      setMouseState("edit");
    }
  }, /*#__PURE__*/_react.default.createElement(_Edit.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Move",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "move" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath14;
      setCursor("crosshair"); //MS
      (_currentPath14 = currentPath) === null || _currentPath14 === void 0 ? void 0 : _currentPath14.remove();
      setMouseState("move");
    }
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faHand
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Node Info",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "node",
    color: showInfo ? "primary" : "default",
    onClick: function onClick() {
      setShowInfo(!showInfo);
    }
  }, /*#__PURE__*/_react.default.createElement(_Info.default, {
    fontSize: "small"
  }))))), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 9.2,
    style: {
      height: "inherit"
    }
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "sketch-canvas",
    id: "sketch-canvas-container",
    style: {
      cursor: cursor || "crosshair"
    }
  }, /*#__PURE__*/_react.default.createElement("canvas", {
    id: sketchPanelId,
    resize: "true"
  }), showPopper && popperLocation && context.selectedSketchElement && /*#__PURE__*/_react.default.createElement(_material.Popover, {
    anchorReference: "anchorPosition",
    open: true,
    hideBackdrop: true,
    className: "sketch-popover",
    disableEnforceFocus: true,
    anchorPosition: popperLocation,
    anchorOrigin: {
      vertical: "top",
      horizontal: "left"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "left"
    }
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-start",
    style: {
      position: "absolute",
      height: "40.75px"
    }
  }, /*#__PURE__*/_react.default.createElement("span", {
    style: {
      paddingLeft: 10,
      fontWeight: "bold",
      color: "#454545"
    }
  }, _lodash.default.capitalize(context.selectedSketchElement.type), " ", context.selectedSketchElement.label)), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-end",
    style: {
      position: "absolute",
      height: "40.75px",
      right: "110px"
    },
    zIndex: 3
  }, /*#__PURE__*/_react.default.createElement(_material.Button, {
    size: "small",
    startIcon: /*#__PURE__*/_react.default.createElement(_Delete.default, null),
    onClick: function onClick() {
      return deleteSketchElement();
    }
  }, "Delete")), typeof attributes != "undefined" ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, attributes.NodeFields || attributes.EdgeFields ? /*#__PURE__*/_react.default.createElement(_QueryBuilder.default, {
    NodeFields: attributes.NodeFields ? attributes.NodeFields : {},
    EdgeFields: attributes.EdgeFields ? attributes.EdgeFields : {}
  }) :
  /*#__PURE__*/
  // loading
  _react.default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  }, /*#__PURE__*/_react.default.createElement(_material.CircularProgress, {
    size: "1.5rem",
    style: {
      marginTop: "30px"
    }
  }))) :
  /*#__PURE__*/
  // general case
  _react.default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  })))), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Clear Sketch",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    color: "default",
    onClick: function onClick() {
      setCursor("crosshair");
      clearSketch();
    }
  }, /*#__PURE__*/_react.default.createElement(_Delete.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Import Motif",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: function onClick() {
      return importMotif();
    }
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileImport
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Export Motif",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: function onClick() {
      return exportMotif();
    }
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileExport,
    style: {
      marginLeft: "0.6em"
    }
  })))))));
}
var _default = SketchPanel;
exports.default = _default;