"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
require("./SketchPanel.css");
var _QueryBuilder = _interopRequireDefault(require("./QueryBuilder"));
var _CircleTwoTone = _interopRequireDefault(require("@mui/icons-material/CircleTwoTone"));
var _ArrowRightAlt = _interopRequireDefault(require("@mui/icons-material/ArrowRightAlt"));
var _Edit = _interopRequireDefault(require("@mui/icons-material/Edit"));
var _Delete = _interopRequireDefault(require("@mui/icons-material/Delete"));
var _Info = _interopRequireDefault(require("@mui/icons-material/Info"));
var _paper = _interopRequireDefault(require("paper"));
var _GlobalContext = require("../contexts/GlobalContext");
var _lodash = _interopRequireDefault(require("lodash"));
var _material = require("@mui/material");
var _reactFontawesome = require("@fortawesome/react-fontawesome");
var _freeSolidSvgIcons = require("@fortawesome/free-solid-svg-icons");
var _mui = require("@react-awesome-query-builder/mui");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
let InitialConfig = _mui.MuiConfig;
delete InitialConfig["conjunctions"]["OR"];
InitialConfig["settings"]["showNot"] = false;
InitialConfig["settings"]["groupOperators"] = false;
InitialConfig["settings"]["canAddGroup"] = false;
InitialConfig["settings"]["canReorder"] = false;
InitialConfig["settings"]["renderSize"] = "small";
InitialConfig["settings"]["setOpOnChangeField"] = ["keep", "first"];
function SketchPanel(props) {
  const {
    attributes
  } = props;
  const sketchPanelId = "sketch-panel";
  let [nodes, setNodes] = (0, _react.useState)([]);
  let [nodeLabels, setNodeLabels] = (0, _react.useState)([]);
  let [edges, setEdges] = (0, _react.useState)([]);
  let [importData, setImportData] = (0, _react.useState)(null);
  let [nodeImportUpdate, setNodeImportUpdate] = (0, _react.useState)(false);
  let [edgeImportUpdate, setEdgeImportUpdate] = (0, _react.useState)(false);
  // States are node (add nodes), edge (add edges), edit(change node/edge properties)
  let [mouseState, setMouseState] = (0, _react.useState)("node");
  let [showInfo, setShowInfo] = (0, _react.useState)(false);
  let [cursor, setCursor] = (0, _react.useState)("crosshair");
  let [pencil, setPencil] = (0, _react.useState)();
  // Checks for mouse intersections
  let [testCircle, setTestCircle] = (0, _react.useState)();
  // Edit properties with boolean query builder
  const [popperLocation, setPopperLocation] = _react.default.useState();
  const [showPopper, setShowPopper] = _react.default.useState(false);
  let circleRadius = 20;
  let currentPath;
  let currentNode;
  let currentSelection;
  const [canvasDimension, setCanvasDimension] = (0, _react.useState)({});
  const [NodeFields, setNodeFields] = (0, _react.useState)(null);
  const [EdgeFields, setEdgeFields] = (0, _react.useState)(null);

  // We track the overall motif in the global context
  const context = (0, _react.useContext)(_GlobalContext.AppContext);
  const calculateNewPosition = (dimension, position) => {
    let newX = canvasDimension.width / dimension.width * position[1];
    let newY = canvasDimension.height / dimension.height * position[2];
    return [Math.floor(newX), Math.floor(newY)];
  };
  const getPositionTransformedData = data => {
    let newNodes = data.nodes.map(node => {
      let [newX, newY] = calculateNewPosition(data.dimension, node.position);
      return {
        ...node,
        position: ["Point", newX, newY]
      };
    });
    let newData = {
      ...data,
      nodes: newNodes,
      dimension: canvasDimension
    };
    return newData;
  };
  const importMotif = () => {
    console.log("importing motif");
    clearSketch(); // clear sketch
    // import file using file picker
    let fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.onchange = e => {
      let file = e.target.files[0];
      // parse file to object
      let reader = new FileReader();
      reader.readAsText(file, "UTF-8");
      reader.onload = e => {
        let data = JSON.parse(e.target.result);
        let newData = getPositionTransformedData(data);
        setImportData(newData);
        setNodeImportUpdate(true);
      };
    };
    fileInput.click();
  };
  const exportMotif = () => {
    console.log("exporting motif");
    console.log(nodes);
    console.log(edges);
    let out = getEncodedMotif(nodes, edges);
    // download out as JSON file
    let json = JSON.stringify(out);
    let blob = new Blob([json], {
      type: "application/json"
    });
    let url = URL.createObjectURL(blob);
    let a = document.createElement("a");
    a.href = url;
    a.download = "motif.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  const clearSketch = () => {
    console.log("Clearing");
    _paper.default?.project?.activeLayer?.removeChildren();
    _paper.default?.view?.draw();
    // Remove all edges and nodes
    setNodes([]);
    setEdges([]);
  };
  const deleteSketchElement = () => {
    // edges
    if (context.selectedSketchElement && context.selectedSketchElement.type === "edge") {
      let newEdges = edges.filter(edge => edge.label !== context.selectedSketchElement.label);
      context.selectedSketchElement.edgeLine.remove();
      context.selectedSketchElement.lineGroup.remove();
      context.selectedSketchElement.propertyLabel?.remove();
      context.setSelectedSketchElement(null);
      setEdges(newEdges);
    }
    // nodes
    if (context.selectedSketchElement && context.selectedSketchElement.type === "node") {
      // find adjacent edges
      let nodeLabel = context.selectedSketchElement.label;
      let adjacentEdges = edges.filter(edge => {
        if (edge.fromNode.label === nodeLabel || edge.toNode.label === nodeLabel) {
          return edge;
        }
      });

      // delete edges from canvas
      adjacentEdges.map(edge => {
        edge.edgeLine.remove();
        edge.lineGroup.remove();
        edge.propertyLabel?.remove();
      });

      // delete node from canvas
      const selectedNodeLabel = context.selectedSketchElement.label;
      context.selectedSketchElement.circle.remove();
      context.selectedSketchElement.circleGroup.remove();
      context.setSelectedSketchElement(null);

      // delete node and rename remaining nodes
      let newNodes = nodes.filter(node => node.label !== selectedNodeLabel).map((node, i) => renameCircle(node.circle, i, node.properties, "tree" in node ? node.tree : null, node.label));
      const getNewNode = previousLabel => newNodes.find(node => node.previousLabel === previousLabel);

      // delete adjacent edges
      let newEdges = edges.filter(edge => !adjacentEdges.includes(edge)).map(edge => {
        let newFromNode = getNewNode(edge.fromNode.label);
        let newToNode = getNewNode(edge.toNode.label);
        let newNodeIndices = [_lodash.default.findLastIndex(newNodes, newFromNode), _lodash.default.findLastIndex(newNodes, newToNode)];
        return renameEdge(newFromNode, newToNode, newNodeIndices, edge);
      });

      // reset edges and nodes
      setEdges(newEdges);
      setNodes(newNodes);
    }
  };
  const renameEdge = (fromNode, toNode, nodeIndices, edge) => {
    let tree = "tree" in edge ? edge.tree : null;
    let edgeObj = {
      ...edge
    };
    edgeObj["fromNode"] = fromNode;
    edgeObj["toNode"] = toNode;
    edgeObj["indices"] = nodeIndices;
    edgeObj["label"] = `${fromNode.label} -> ${toNode.label}`;
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    return edgeObj;
  };
  const renameCircle = function (circle, index) {
    let properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    let previousLabel = arguments.length > 4 ? arguments[4] : undefined;
    circle.fillColor = context.neuronColors[index];
    let textPoint = [circle.position.x, circle.position.y + 7];
    let label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 20
    });
    let letter = String.fromCharCode(65 + index);
    label.content = letter;
    let circleGroup = new _paper.default.Group([circle, label]);
    if (tree !== null) {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup,
        tree: _mui.Utils.loadTree(tree)
      };
    } else {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup
      };
    }
  };
  const addCircle = (point, node) => {
    // add circle to paper
    let circle = new _paper.default.Path.Circle(point, circleRadius);
    circle.strokeColor = "#000000";
    circle.strokeWidth = 3;
    circle.fillColor = context.neuronColors[node.index];
    circle.opacity = 1.0;
    circle.position = point;
    placeCircle(circle, node.label, node.properties, "tree" in node ? node.tree : null);
  };
  const placeCircle = function (circle, letter) {
    let properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    circle.opacity = 1;
    let textPoint = [circle.position.x, circle.position.y + 7];
    let label = new _paper.default.PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 20
    });
    label.content = letter;
    currentPath?.remove();
    currentPath = null;
    let circleGroup = new _paper.default.Group([circle, label]);
    if (tree !== null) {
      setNodes(nodes => [...nodes, {
        circle: circle,
        label: letter,
        properties: properties,
        type: "node",
        circleGroup: circleGroup,
        tree: _mui.Utils.loadTree(tree)
      }]);
    } else {
      setNodes(nodes => [...nodes, {
        circle: circle,
        label: letter,
        properties: properties,
        type: "node",
        circleGroup: circleGroup
      }]);
    }
  };
  const bindPencilEvents = () => {
    currentPath = null;
    pencil.onMouseMove = function (event) {
      let point = new _paper.default.Point(event.point);
      testCircle.position = point;
      if (mouseState === "node") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        let numNodes = nodes?.length || 0;
        let color = numNodes <= context.neuronColors.length ? context.neuronColors[numNodes] : "#000000";
        // Create new Circle
        if (!currentPath) {
          currentPath = new _paper.default.Path.Circle(point, circleRadius);
          currentPath.strokeColor = "#000000";
          currentPath.strokeWidth = 3;
          currentPath.fillColor = color;
          currentPath.opacity = 0.5;
        } else {
          // Move existing circle
          currentPath.position = point;
        }
      } else if (mouseState === "edge") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        if (!currentPath) {
          currentPath = new _paper.default.Path();
          currentPath.strokeColor = "#000000";
          currentPath.strokeWidth = 3;
          currentPath.opacity = 0.5;
          currentPath.add([point.x - 10, point.y]);
          currentPath.add([point.x + 10, point.y]);
        }
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        // Starting Point of Edge
        if (intersections === -1 && currentNode) {
          currentPath.segments[0].point = currentNode.circle.getNearestPoint(point);
          currentPath.segments[1].point = point;
        } //    Ending Point of Edge
        else if (intersections !== -1 && currentNode && !_lodash.default.isEqual(currentNode, nodes[intersections])) {
          currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[intersections].circle.position);
          currentPath.segments[1].point = nodes[intersections].circle.getNearestPoint(currentNode.circle.position);
        } // Otherwise move the line glyph
        else {
          currentPath.segments[0].point = new _paper.default.Point([point.x - 10, point.y]);
          currentPath.segments[1].point = new _paper.default.Point([point.x + 10, point.y]);
        }
      } else if (mouseState === "edit") {
        // Check with intersections with nodes
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        // Check with intersections with nodes
        if (intersections !== -1) {
          currentSelection = nodes[intersections];
          return;
        }
        // Check with intersections with edges
        intersections = _lodash.default.findLastIndex(edges.map(e => {
          return !_lodash.default.isEmpty(testCircle?.getIntersections(e.edgeLine));
        }), e => e === true);
        if (intersections !== -1) {
          currentSelection = edges[intersections];
          return;
        }
        currentSelection = null;
      } else if (mouseState === "move") {
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        // Check with intersections with nodes
        if (intersections !== -1) {
          currentSelection = nodes[intersections];
          nodes[intersections].circle.selected = true;
        } else {
          currentSelection = null;
          _paper.default.project.activeLayer.selected = false;
        }
      }
    };
    pencil.onMouseDown = function (event) {
      let point = new _paper.default.Point(event.point);
      if (mouseState === "node") {
        if (!currentPath) return;
        // Create new node
        let numNodes = nodes?.length || 0;
        let letter = String.fromCharCode(65 + numNodes);
        let circle = currentPath.clone();
        placeCircle(circle, letter);
      } else if (mouseState === "edge") {
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        if (intersections !== -1 && !currentNode && currentPath) {
          currentNode = nodes[intersections];
          currentPath.segments[0].position = currentNode.circle.getNearestPoint(point);
          return;
        } else if (currentPath && intersections !== -1) {
          if (!_lodash.default.isEqual(currentNode, nodes[intersections])) {
            // If line intersects with two nodes, draw edge
            currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[intersections].circle.position);
            currentPath.segments[1].point = nodes[intersections].circle.getNearestPoint(currentNode.circle.position);
            let edge = currentPath.clone();
            edge.opacity = 1;
            addEdge(currentNode, nodes[intersections], edge);
          }
        }
        currentPath?.remove();
        currentNode = null;
        currentPath = null;
      } else if (mouseState === "edit") {
        let nodeIntersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        let edgeIntersections = _lodash.default.findLastIndex(edges.map(e => {
          return !_lodash.default.isEmpty(testCircle?.getIntersections(e.edgeLine));
        }), e => e === true);
        // select the clicked on element and show the popper
        if (nodeIntersections !== -1 || edgeIntersections !== -1) {
          context.setSelectedSketchElement(currentSelection);
          let selectedElement = currentSelection?.lineGroup || currentSelection?.circle;
          _paper.default.project.activeLayer.selected = false;
          selectedElement.selected = true;
          setShowPopper(true);
        } else {
          // If they click out, make the popper go away
          setShowPopper(false);
          context.setSelectedSketchElement(null);
          setPopperLocation(null);
        }
      } else if (mouseState === "move") {
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        // Check with intersections with nodes
        if (intersections !== -1) {
          currentSelection = nodes[intersections];
        }
        if (currentSelection) {
          setCursor("grabbing");
        }
      }
    };
    pencil.onMouseUp = function (event) {
      if (mouseState === "move") {
        console.log("grab", currentNode);
        let nodeIndex = _lodash.default.findLastIndex(nodes.map(n => n.label === currentNode.label));
        // // list of edges including this edge
        let tmpEdges = _lodash.default.clone(edges);
        let edgesToAddAgain = [];
        let filteredEdges = tmpEdges.filter(e => {
          if (e.indices.includes(nodeIndex)) {
            edgesToAddAgain.push(e);
            return false;
          }
          return true;
        });
        let newEdges = edgesToAddAgain.map(e => {
          e.edgeLine.opacity = 1;
          return createEdge(e.fromNode, e.toNode, e.edgeLine, e.indices, e.properties, e.tree, e.propertyLabel);
        });
        setEdges([...newEdges, ...filteredEdges]);
        setCursor("grab");
      }
    };
    pencil.onMouseDrag = function (event) {
      if (mouseState === "move") {
        nodeLabels.forEach(label => {
          label?.remove();
        });
        let intersections = _lodash.default.findLastIndex(nodes.map(n => {
          return n.circle.contains(event.point);
        }), e => e === true);
        // Check with intersections with nodes
        if (intersections === -1) return;
        nodes[intersections].circleGroup.position = new _paper.default.Point(event.point);
        currentNode = nodes[intersections];
        edges.forEach((e, i) => {
          if (e.indices.includes(intersections)) {
            if (e.lineGroup) {
              edges[i].edgeLine.remove();
              edges[i].lineGroup.remove();
              edges[i].propertyLabel?.remove();
              edges[i].edgeLine = null;
              edges[i].edgeLine = null;
              edges[i].oppositeEdge = null;
              edges[i].edgeLine = new _paper.default.Path();
              edges[i].edgeLine.strokeColor = "#000000";
              edges[i].edgeLine.strokeWidth = 3;
              edges[i].edgeLine.opacity = 0.5;
              edges[i].edgeLine.add([0, 0]);
              edges[i].edgeLine.add([0, 0]);
            }
            edges[i].edgeLine.segments[0].point = nodes[e.indices[0]].circle.getNearestPoint(nodes[e.indices[1]].circle.position);
            edges[i].edgeLine.segments[1].point = nodes[e.indices[1]].circle.getNearestPoint(nodes[e.indices[0]].circle.position);
          }
        });
      }
    };
  };
  const addEdge = function (fromNode, toNode, edgeLine) {
    let properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    let tree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    let addEdgeImmediately = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    let nodeIndices = [_lodash.default.findLastIndex(nodes, fromNode), _lodash.default.findLastIndex(nodes, toNode)];
    let matchingEdge = _lodash.default.findIndex(edges, e => {
      return _lodash.default.isEqual(e.indices, nodeIndices);
    });
    if (matchingEdge !== -1) {
      console.log("Edge Exists");
      edgeLine.remove();
      return;
    }
    const newEdgeObj = createEdge(fromNode, toNode, edgeLine, nodeIndices, properties, tree);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([...edges, newEdgeObj]);
    }
    return newEdgeObj;
  };
  const addExistEdges = newEdges => {
    let output = [];
    newEdges.map(edge => {
      let path = new _paper.default.Path();
      path.strokeColor = "#000000";
      path.strokeWidth = 3;
      path.opacity = 1.0;
      path.add([edge.fromNode.circle.position[1], edge.fromNode.circle.position[2]]);
      path.add([edge.toNode.circle.position[1], edge.toNode.circle.position[2]]);
      let startNode = nodes[edge.indices[0]];
      let endNode = nodes[edge.indices[1]];
      path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
      path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
      let tree = "tree" in edge ? edge.tree : null;
      let _newEdge = createEdge(startNode, endNode, path, edge.indices, edge.properties, tree);
      output.push(_newEdge);
    });
    setEdges([...output]);
  };
  const createEdge = function (fromNode, toNode, edgeLine, nodeIndices) {
    let properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    let tree = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    let propertyLabel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    let edgeObj = {
      indices: nodeIndices,
      toNode: toNode,
      fromNode: fromNode,
      edgeLine: edgeLine
    };
    // If this edge already exists, don't create it
    // Checks from an edge going the opposite direction between the same two nodes
    let origToPoint = _lodash.default.cloneDeep(edgeLine.segments[0].point);
    let circ = new _paper.default.Path.Circle(origToPoint, 8);
    let toPoint = edgeLine.segments[0].point = circ.getIntersections(edgeLine)[0].point;
    circ.remove();
    let origFromPoint = _lodash.default.cloneDeep(edgeLine.segments[1].point);
    circ = new _paper.default.Path.Circle(origFromPoint, 8);
    let fromPoint = edgeLine.segments[1].point = circ.getIntersections(edgeLine)[0].point;
    const dy = toPoint.y - fromPoint.y;
    const dx = toPoint.x - fromPoint.x;
    const theta = Math.atan2(dy, dx); // range (-PI, PI]
    const newY = 7 * Math.sin(theta) + fromPoint.y;
    const newX = 7 * Math.cos(theta) + fromPoint.x;
    let circle = new _paper.default.Path.Circle([newX, newY], 7);
    // Check where the arrow head points should be
    let secondCircle = new _paper.default.Path.Circle(circle.getNearestPoint(toPoint), 7);
    let intersections = secondCircle.getIntersections(circle).map(intersection => intersection.point);
    intersections.splice(1, 0, fromPoint);
    let trianglePath = new _paper.default.Path(intersections);
    trianglePath.strokeColor = "black";
    trianglePath.strokeWidth = 3;
    trianglePath.strokeJoin = "round";
    // Create a big group with line and arrow
    edgeObj["toPoint"] = toPoint;
    edgeObj["fromPoint"] = fromPoint;
    edgeObj["lineGroup"] = new _paper.default.Group([trianglePath, edgeObj.edgeLine]);
    secondCircle?.remove();
    circle?.remove();
    edgeObj["type"] = "edge";
    edgeObj["label"] = `${edgeObj.fromNode.label} -> ${edgeObj.toNode.label}`;
    edgeObj["properties"] = properties;
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    if (propertyLabel) edgeObj = addEdgePropertyLabel(edgeObj);
    return edgeObj;
  };
  const addEdgePropertyLabel = e => {
    // Remove any existing label
    if (!e.properties) return e;
    e.propertyLabel?.remove();
    let midpoint = new _paper.default.Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
    let midpointCircle = new _paper.default.Path.Circle(midpoint, 10);
    let intersectionsCircles = midpointCircle.getIntersections(e.lineGroup.children[1]).map(i => {
      return new _paper.default.Path.Circle(i.point, 15);
    });
    let drawPoints = intersectionsCircles[0].getIntersections(intersectionsCircles[1]).map(i => i.point);
    let topPoint = _lodash.default.sortBy(drawPoints, "y")[0];
    midpointCircle.remove();
    intersectionsCircles.map(i => i.remove());
    let labelText = "";
    if ("weight" in e.properties) {
      if (_lodash.default.isNumber(e.properties.weight)) {
        labelText = e.properties.weight;
      } else if (e.properties.weight["$lt"]) {
        labelText = "< " + e.properties.weight["$lt"];
      } else if (e.properties.weight["$gt"]) {
        labelText = "> " + e.properties.weight["$gt"];
      }
    }
    let propertyLabel = new _paper.default.PointText({
      point: topPoint,
      justification: "center",
      fillColor: "black",
      font: "Roboto",
      fontSize: 14
    });
    propertyLabel.content = labelText;
    e.propertyLabel = propertyLabel;
    return e;
  };
  (0, _react.useEffect)(() => {
    if (importData && nodeImportUpdate) {
      importData.nodes.forEach(node => {
        let point = new _paper.default.Point(node.position[1], node.position[2]);
        addCircle(point, node);
      });
      setNodeImportUpdate(false);
      setEdgeImportUpdate(true);
    }
  }, [nodeImportUpdate]);
  (0, _react.useEffect)(() => {
    if (importData && edgeImportUpdate) {
      let newEdges = [];
      try {
        importData.edges.forEach(edge => {
          let myInputStartNode = importData.nodes.find(node => node.index === edge.indices[0]);
          let myInputEndNode = importData.nodes.find(node => node.index === edge.indices[1]);
          let path = new _paper.default.Path();
          path.strokeColor = "#000000";
          path.strokeWidth = 3;
          path.opacity = 1.0;
          path.add([myInputStartNode.position[1], myInputStartNode.position[2]]);
          path.add([myInputEndNode.position[1], myInputEndNode.position[2]]);
          let startNode = nodes[edge.indices[0]];
          let endNode = nodes[edge.indices[1]];
          path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
          path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
          let tree = "tree" in edge ? edge.tree : null;
          let newEdge = addEdge(startNode, endNode, path, edge.properties, tree, false);
          newEdges.push(newEdge);
        });
        context.setErrorMessage(null);
        // context.setLoadingMessage(null);
      } catch (TypeError) {
        context.setErrorMessage("The motif can't import. Please try again in a larger window.");
        // context.setLoadingMessage(null);
        clearSketch();
      }

      // add new edges to edges
      setEdges([...edges, ...newEdges]);
      setEdgeImportUpdate(false);
      setImportData(null);
    }
  }, [edgeImportUpdate]);

  // Checks for edges going opposite to each other and offsets them so they are distinguishable
  (0, _react.useEffect)(() => {
    if (!edges) return;
    edges.forEach((e, i) => {
      let oppositeEdge = _lodash.default.findIndex(edges, oppE => {
        return _lodash.default.isEqual(oppE.indices, [e.indices[1], e.indices[0]]);
      });
      if (oppositeEdge !== -1 && !e.oppositeEdge && oppositeEdge > i) {
        let midpoint = new _paper.default.Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
        let circle1 = new _paper.default.Path.Circle(midpoint, 5);
        let circle2 = new _paper.default.Path.Circle(circle1.getIntersections(edges[oppositeEdge].edgeLine)[0].point, Math.sqrt(5 ** 2 + 5 ** 2));
        let pointDelta = circle2.getIntersections(circle1).map(e => e.point).sort((a, b) => {
          return a.y - b.y;
        }).map(pt => new _paper.default.Point([midpoint.x - pt.x, midpoint.y - pt.y]));
        e["lineGroup"].translate(pointDelta[0]);
        edges[oppositeEdge]["lineGroup"].translate(pointDelta[1]);
        edges[oppositeEdge]["oppositeEdge"] = i;
        e["oppositeEdge"] = oppositeEdge;
      }
      if (e.properties === undefined && e.propertyLabel) {
        e.propertyLabel.content = "";
      }
    });
  }, [edges]);
  (0, _react.useEffect)(() => {
    if (pencil && mouseState) {
      // Rebind the pencil events whenever new nodes are drawn
      bindPencilEvents();
    }
  }, [pencil, mouseState, nodes, edges]);
  (0, _react.useEffect)(() => {
    currentPath?.remove();
    setPopperLocation(null);
    setShowPopper(false);
    if (_paper.default?.project?.activeLayer) {
      _paper.default.project.activeLayer.selected = false;
      // Remove all undrawn shapes when you switch modes
      _paper.default.project.activeLayer.children.forEach(child => {
        if (child.opacity === 0.5) child.remove();
      });
    }
  }, [mouseState]);
  (0, _react.useEffect)(() => {
    // if context.selectedSketchElement is not null
    if (context.selectedSketchElement) {
      let paperElement = context.selectedSketchElement?.circle || context?.selectedSketchElement?.edgeLine;
      // Calculate where on screen coordinates the popper should go
      let position = paperElement.getPosition();
      let boundingRect = _paper.default.view.element.getBoundingClientRect();
      if (paperElement && position) {
        setPopperLocation({
          top: position.y + boundingRect.top + 30,
          left: position.x + boundingRect.left - 30
        });
      }
      if (context.selectedSketchElement.type === "edge") {
        setEdges(edges.map(e => {
          // Update the edge with the query properties
          if (_lodash.default.isEqual(e.edgeLine, context.selectedSketchElement.edgeLine)) {
            e.tree = context.selectedSketchElement.tree;
            e.properties = context.selectedSketchElement.properties;
            e = addEdgePropertyLabel(e);
          }
          if (e.fromNode.label === context.selectedSketchElement.fromNode.label && e.toNode.label === context.selectedSketchElement.toNode.label) {
            e.edgeLine.strokeColor = "red";
            e.lineGroup.children[0].strokeColor = "red";
          } else {
            e.edgeLine.strokeColor = "#000000";
            e.lineGroup.children[0].strokeColor = "#000000";
          }
          return e;
        }));
      } else {
        setNodes(nodes.map(n => {
          if (_lodash.default.isEqual(n.circle, context.selectedSketchElement.circle)) {
            // Update the node with the query properties
            n.tree = context.selectedSketchElement.tree;
            n.properties = context.selectedSketchElement.properties;
          }
          return n;
        }));
      }
    } else {
      setPopperLocation(null);
      setEdges(edges.map(e => {
        e.edgeLine.strokeColor = "#000000";
        e.lineGroup.children[0].strokeColor = "#000000";
        return e;
      }));
    }
  }, [context.selectedSketchElement]);

  // On init set up our paperjs
  (0, _react.useEffect)(() => {
    _paper.default.setup(sketchPanelId);
    _paper.default.view.onResize = function () {
      setCanvasDimension(_paper.default.view.size);
    };
    setCanvasDimension(_paper.default.view.size);
    let tempCircle = new _paper.default.Path.Circle([0, 0], 6);
    tempCircle.fill = "none";
    tempCircle.strokeWidth = 0;
    setTestCircle(tempCircle);
    let tool = new _paper.default.Tool();
    if (!pencil) {
      setPencil(tool);
    }
    // fetch Node and Edge Fields
    if (!NodeFields || !EdgeFields) {
      if (typeof attributes !== "undefined") {
        setNodeFields(attributes.NodeFields);
        setEdgeFields(attributes.EdgeFields);
      }
    }
    if (nodes.length > 0) {
      const newNodes = [...nodes];
      setNodes([]);
      newNodes.map(node => {
        placeCircle(node.circle, node.label, node.properties, node.tree);
      });
    }
    if (edges.length > 0) {
      const newEdges = [...edges];
      addExistEdges(newEdges);
    }
    return () => {
      // cleanup component once destroyed
      tool.remove();
      tool.off("mousemove");
      tool.off("mousedown");
      tool.off("mouseup");
    };
  }, []);
  const getEncodedMotif = (nodes, edges) => {
    let encodedNodes = nodes.map((n, i) => {
      return {
        label: n.label,
        properties: n.properties,
        index: i,
        position: n.circle.position,
        tree: n.tree
      };
    });
    let encodedEdges = edges.map((e, i) => {
      return {
        label: e.label,
        properties: e.properties,
        index: i,
        indices: e.indices,
        tree: e.tree
      };
    });
    let sketchPanelDim = {
      width: canvasDimension.width,
      height: canvasDimension.height
    };
    return {
      nodes: encodedNodes,
      edges: encodedEdges,
      dimension: sketchPanelDim
    };
  };
  // Encode the Nodes and Edges For Query
  (0, _react.useEffect)(() => {
    let encodedMotif = getEncodedMotif(nodes, edges);
    context.setMotifQuery(encodedMotif);

    // most motif queries fail for n larger than 4, develop heuristics to make more accurate
    // nodes.length > 4
    //   ? context.setShowWarning(true)
    //   : context.setShowWarning(false);
    // if (
    //   typeof attributes != "undefined" &&
    //   attributes.getMotifCount &&
    //   attributes.getRelativeMotifCount
    // ) {
    //   const count = await attributes.getMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setAbsMotifCount(count);

    //   // get relative count of motif in network
    //   const relative_count = await attributes.getRelativeMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setRelativeMotifCount(relative_count);
    // }
  }, [nodes, edges]);
  const isObject = obj => {
    return Object.prototype.toString.call(obj) === "[object Object]";
  };
  const parsePropertyText = (key, value) => {
    let parsedValue = "";
    if (isObject(value)) {
      if (value["$ne"]) {
        parsedValue = `Not ${value["$ne"]}`;
      } else if (value["$lt"]) {
        parsedValue = "< " + value["$lt"];
      } else if (value["$gt"]) {
        parsedValue = "> " + value["$gt"];
      }
    } else {
      parsedValue = value;
    }
    return `${key}: ${parsedValue}\n`;
  };
  (0, _react.useEffect)(() => {
    if (!nodes) return;
    nodeLabels.forEach(label => {
      label?.remove();
    });
    setNodeLabels(nodes.map(n => {
      if (!showInfo) return null;
      console.log("nodes", n, "show", showInfo);
      let propertiesText = _lodash.default.entries(n?.properties).map(p => {
        return parsePropertyText(p[0], p[1]);
      });
      let labelPoint = [n.circle.position.x, n.circle.position.y - circleRadius - 10 * propertiesText.length];
      let label = new _paper.default.PointText({
        point: labelPoint,
        justification: "center",
        fillColor: "black",
        font: "Roboto",
        fontSize: 10
      });
      label.content = propertiesText.join("");
      return label;
    }));
  }, [nodes, showInfo, edges]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "sketch-panel-style"
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "canvas-wrapper",
    spacing: 0
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Draw Node",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "node",
    color: mouseState === "node" ? "primary" : "default",
    onClick: () => {
      currentPath?.remove();
      setCursor("crosshair");
      setMouseState("node");
    }
  }, /*#__PURE__*/_react.default.createElement(_CircleTwoTone.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Draw Edge",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    color: mouseState === "edge" ? "primary" : "default",
    onClick: () => {
      currentPath?.remove();
      setCursor("crosshair");
      setMouseState("edge");
    }
  }, /*#__PURE__*/_react.default.createElement(_ArrowRightAlt.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Edit Properties",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "edit" ? "primary" : "default",
    onClick: () => {
      setCursor("pointer");
      currentPath?.remove();
      setMouseState("edit");
    }
  }, /*#__PURE__*/_react.default.createElement(_Edit.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Move",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "move" ? "primary" : "default",
    onClick: () => {
      setCursor("grab");
      currentPath?.remove();
      setMouseState("move");
    }
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faHand
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Node Info",
    placement: "right"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "node",
    color: showInfo ? "primary" : "default",
    onClick: () => {
      setShowInfo(!showInfo);
    }
  }, /*#__PURE__*/_react.default.createElement(_Info.default, {
    fontSize: "small"
  }))))), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 9.2,
    style: {
      height: "inherit"
    }
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "sketch-canvas",
    id: "sketch-canvas-container",
    style: {
      cursor: cursor || "crosshair"
    }
  }, /*#__PURE__*/_react.default.createElement("canvas", {
    id: sketchPanelId,
    resize: "true"
  }), showPopper && popperLocation && context.selectedSketchElement && /*#__PURE__*/_react.default.createElement(_material.Popover, {
    anchorReference: "anchorPosition",
    open: true,
    hideBackdrop: true,
    className: "sketch-popover",
    disableEnforceFocus: true,
    anchorPosition: popperLocation,
    anchorOrigin: {
      vertical: "top",
      horizontal: "left"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "left"
    }
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-start",
    style: {
      position: "absolute",
      height: "40.75px"
    }
  }, /*#__PURE__*/_react.default.createElement("span", {
    style: {
      paddingLeft: 10,
      fontWeight: "bold",
      color: "#454545"
    }
  }, _lodash.default.capitalize(context.selectedSketchElement.type), " ", context.selectedSketchElement.label)), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-end",
    style: {
      position: "absolute",
      height: "40.75px",
      right: "110px"
    },
    zIndex: 3
  }, /*#__PURE__*/_react.default.createElement(_material.Button, {
    size: "small",
    startIcon: /*#__PURE__*/_react.default.createElement(_Delete.default, null),
    onClick: () => deleteSketchElement()
  }, "Delete")), typeof attributes != "undefined" ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, attributes.NodeFields || attributes.EdgeFields ? /*#__PURE__*/_react.default.createElement(_QueryBuilder.default, {
    NodeFields: attributes.NodeFields ? attributes.NodeFields : {},
    EdgeFields: attributes.EdgeFields ? attributes.EdgeFields : {}
  }) :
  /*#__PURE__*/
  // loading
  _react.default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  }, /*#__PURE__*/_react.default.createElement(_material.CircularProgress, {
    size: "1.5rem",
    style: {
      marginTop: "30px"
    }
  }))) :
  /*#__PURE__*/
  // general case
  _react.default.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  })))), /*#__PURE__*/_react.default.createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react.default.createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Clear Sketch",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    color: "default",
    onClick: () => {
      setCursor("crosshair");
      clearSketch();
    }
  }, /*#__PURE__*/_react.default.createElement(_Delete.default, {
    fontSize: "small"
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Import Motif",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: () => importMotif()
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileImport
  }))), /*#__PURE__*/_react.default.createElement(_material.Tooltip, {
    title: "Export Motif",
    placement: "left"
  }, /*#__PURE__*/_react.default.createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: () => exportMotif()
  }, /*#__PURE__*/_react.default.createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileExport,
    style: {
      marginLeft: "0.6em"
    }
  })))))));
}
var _default = SketchPanel;
exports.default = _default;