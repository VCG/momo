"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whatRulePropertiesAreCompleted = exports.selectTypes = exports.isEmptyRuleProperties = exports.isEmptyRuleGroupExtPropertiesAndChildren = exports.isEmptyItem = exports.isEmptyGroupChildren = exports.getWidgetsForFieldOp = exports.getWidgetForFieldOp = exports.getValueSourcesForFieldOp = exports.getValueLabel = exports.getOperatorsForType = exports.getOperatorsForField = exports.getOneChildOrDescendant = exports.getFuncPathLabels = exports.getFirstOperator = exports.getFieldPathLabels = exports.getFieldPartsConfigs = exports.formatFieldName = exports.filterValueSourcesForField = exports.completeValue = exports.calculateValueType = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _configUtils = require("./configUtils");
var _last = _interopRequireDefault(require("lodash/last"));
var _funcUtils = require("./funcUtils");
var selectTypes = exports.selectTypes = ["select", "multiselect", "treeselect", "treemultiselect"];
var getOperatorsForType = exports.getOperatorsForType = function getOperatorsForType(config, fieldType) {
  var _config$types$fieldTy;
  return ((_config$types$fieldTy = config.types[fieldType]) === null || _config$types$fieldTy === void 0 ? void 0 : _config$types$fieldTy.operators) || null;
};
var getOperatorsForField = exports.getOperatorsForField = function getOperatorsForField(config, field) {
  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);
  var fieldOps = fieldConfig ? fieldConfig.operators : [];
  return fieldOps;
};
var getFirstOperator = exports.getFirstOperator = function getFirstOperator(config, field) {
  var _fieldOps$;
  var fieldOps = getOperatorsForField(config, field);
  return (_fieldOps$ = fieldOps === null || fieldOps === void 0 ? void 0 : fieldOps[0]) !== null && _fieldOps$ !== void 0 ? _fieldOps$ : null;
};
var calculateValueType = exports.calculateValueType = function calculateValueType(value, valueSrc, config) {
  var calculatedValueType = null;
  if (value) {
    if (valueSrc === "field") {
      var fieldConfig = (0, _configUtils.getFieldConfig)(config, value);
      if (fieldConfig) {
        calculatedValueType = fieldConfig.type;
      }
    } else if (valueSrc === "func") {
      var funcKey = value.get("func");
      if (funcKey) {
        var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);
        if (funcConfig) {
          calculatedValueType = funcConfig.returnType || funcConfig.type;
        }
      }
    }
  }
  return calculatedValueType;
};
var getFuncPathLabels = exports.getFuncPathLabels = function getFuncPathLabels(field, config) {
  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return getFieldPathLabels(field, config, parentField, "funcs", "subfields");
};
var getFieldPathLabels = exports.getFieldPathLabels = function getFieldPathLabels(field, config) {
  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "fields";
  var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "subfields";
  if (!field) return null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parts = (0, _configUtils.getFieldParts)(field, config);
  var parentParts = (0, _configUtils.getFieldParts)(parentField, config);
  var res = parts.slice(parentParts.length).map(function (_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function (parts) {
    return [].concat((0, _toConsumableArray2["default"])(parentParts), (0, _toConsumableArray2["default"])(parts)).join(fieldSeparator);
  }).map(function (part) {
    var cnf = (0, _configUtils.getFieldRawConfig)(config, part, fieldsKey, subfieldsKey);
    return cnf && cnf.label || (0, _last["default"])(part.split(fieldSeparator));
  }).filter(function (label) {
    return label != null;
  });
  return res;
};
var getFieldPartsConfigs = exports.getFieldPartsConfigs = function getFieldPartsConfigs(field, config) {
  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!field) return null;
  var parentFieldDef = parentField && (0, _configUtils.getFieldRawConfig)(config, parentField) || null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parts = (0, _configUtils.getFieldParts)(field, config);
  var isDescendant = (0, _configUtils.isFieldDescendantOfField)(field, parentField, config);
  var parentParts = !isDescendant ? [] : (0, _configUtils.getFieldParts)(parentField, config);
  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function (parts) {
    return {
      part: [].concat((0, _toConsumableArray2["default"])(parentParts), (0, _toConsumableArray2["default"])(parts)).join(fieldSeparator),
      key: parts[parts.length - 1]
    };
  }).map(function (_ref) {
    var part = _ref.part,
      key = _ref.key;
    var cnf = (0, _configUtils.getFieldRawConfig)(config, part);
    return {
      key: key,
      cnf: cnf
    };
  }).map(function (_ref2, ind, arr) {
    var key = _ref2.key,
      cnf = _ref2.cnf;
    var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
    return [key, cnf, parentCnf];
  });
};
var getValueLabel = exports.getValueLabel = function getValueLabel(config, field, operator, delta) {
  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  // const isFuncArg = field && typeof field == "object" && !!field.func && !!field.arg;
  // const {showLabels} = config.settings;
  // const fieldConfig = getFieldConfig(config, field);
  var fieldWidgetConfig = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, null, valueSrc) || {};
  var mergedOpConfig = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};
  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
  var ret = null;
  if (cardinality > 1) {
    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
    if (valueLabels) ret = valueLabels[delta];
    if (ret && (0, _typeof2["default"])(ret) !== "object") {
      ret = {
        label: ret,
        placeholder: ret
      };
    }
    if (!ret) {
      ret = {
        label: config.settings.valueLabel + " " + (delta + 1),
        placeholder: config.settings.valuePlaceholder + " " + (delta + 1)
      };
    }
  } else {
    var label = fieldWidgetConfig.valueLabel;
    var placeholder = fieldWidgetConfig.valuePlaceholder;
    // tip: this logic moved to extendFieldConfig(), see comment "label for func arg"
    // if (isFuncArg) {
    //   if (!label)
    //     label = fieldConfig.label || field.arg;
    //   if (!placeholder && !showLabels)
    //     placeholder = fieldConfig.label || field.arg;
    // }

    ret = {
      label: label || config.settings.valueLabel,
      placeholder: placeholder || config.settings.valuePlaceholder
    };
  }
  return ret;
};
function _getWidgetsAndSrcsForFieldOp(config, field) {
  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var widgets = [];
  var valueSrcs = [];
  if (!field) return {
    widgets: widgets,
    valueSrcs: valueSrcs
  };
  var fieldCacheKey = (0, _configUtils.getFieldId)(field);
  var cacheKey = fieldCacheKey ? "".concat(fieldCacheKey, "__").concat(operator, "__").concat(valueSrc) : null;
  var cached = (0, _configUtils._getFromConfigCache)(config, "_getWidgetsAndSrcsForFieldOp", cacheKey);
  if (cached) return cached;
  var isFuncArg = (0, _typeof2["default"])(field) === "object" && (!!field.func && !!field.arg || field._isFuncArg);
  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);
  var opConfig = operator ? config.operators[operator] : null;
  if (fieldConfig !== null && fieldConfig !== void 0 && fieldConfig.widgets) {
    var _loop = function _loop() {
      var widgetConfig = fieldConfig.widgets[widget];
      if (!config.widgets[widget]) {
        return 1; // continue
      }
      var widgetValueSrc = config.widgets[widget].valueSrc || "value";
      var canAdd = true;
      if (widget === "field") {
        canAdd = canAdd && filterValueSourcesForField(config, ["field"], fieldConfig).length > 0;
      }
      if (widget === "func") {
        canAdd = canAdd && filterValueSourcesForField(config, ["func"], fieldConfig).length > 0;
      }
      // If can't check operators, don't add
      // Func args don't have operators
      if (valueSrc === "value" && !widgetConfig.operators && !isFuncArg && field !== "!case_value") canAdd = false;
      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
      if (valueSrc && valueSrc != widgetValueSrc && valueSrc !== "const") canAdd = false;
      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc !== "value") canAdd = false;
      if (canAdd) {
        var _fieldConfig$valueSou, _opConfig$valueSource;
        widgets.push(widget);
        var canAddValueSrc = ((_fieldConfig$valueSou = fieldConfig.valueSources) === null || _fieldConfig$valueSou === void 0 ? void 0 : _fieldConfig$valueSou.indexOf(widgetValueSrc)) != -1;
        if ((opConfig === null || opConfig === void 0 || (_opConfig$valueSource = opConfig.valueSources) === null || _opConfig$valueSource === void 0 ? void 0 : _opConfig$valueSource.indexOf(widgetValueSrc)) == -1) canAddValueSrc = false;
        if (canAddValueSrc && !valueSrcs.find(function (v) {
          return v == widgetValueSrc;
        })) valueSrcs.push(widgetValueSrc);
      }
    };
    for (var widget in fieldConfig.widgets) {
      if (_loop()) continue;
    }
  }
  var widgetWeight = function widgetWeight(w) {
    var wg = 0;
    if (fieldConfig.preferWidgets) {
      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);
    } else if (w == fieldConfig.mainWidget) {
      wg += 100;
    }
    if (w === "field") {
      wg -= 1;
    }
    if (w === "func") {
      wg -= 2;
    }
    return wg;
  };
  widgets.sort(function (w1, w2) {
    return widgetWeight(w2) - widgetWeight(w1);
  });
  var res = {
    widgets: widgets,
    valueSrcs: valueSrcs
  };
  (0, _configUtils._saveToConfigCache)(config, "_getWidgetsAndSrcsForFieldOp", cacheKey, res);
  return res;
}
var getWidgetsForFieldOp = exports.getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
    widgets = _getWidgetsAndSrcsFor.widgets;
  return widgets;
};
var filterValueSourcesForField = exports.filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {
  var _fieldDefinition$type;
  if (!fieldDefinition) return valueSrcs;
  var fieldType = (_fieldDefinition$type = fieldDefinition.type) !== null && _fieldDefinition$type !== void 0 ? _fieldDefinition$type : fieldDefinition.returnType;
  if (fieldType === "!group") {
    // todo: aggregation can be not only number?
    fieldType = "number";
  }
  // const { _isCaseValue } = fieldDefinition;
  if (!valueSrcs) valueSrcs = Object.keys(config.settings.valueSourcesInfo);
  return valueSrcs.filter(function (vs) {
    var canAdd = true;
    if (vs === "field") {
      if (config.__fieldsCntByType) {
        // tip: LHS field can be used as arg in RHS function
        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;
        canAdd = canAdd && config.__fieldsCntByType[fieldType] > minCnt;
      }
    }
    if (vs === "func") {
      if (fieldDefinition.funcs) {
        canAdd = canAdd && fieldDefinition.funcs.length > 0;
      }
      if (config.__funcsCntByType) {
        canAdd = canAdd && config.__funcsCntByType[fieldType] > 0;
      }
    }
    return canAdd;
  });
};
var getValueSourcesForFieldOp = exports.getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {
  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),
    valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;
  var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);
  return filteredValueSrcs;
};
var getWidgetForFieldOp = exports.getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
    widgets = _getWidgetsAndSrcsFor3.widgets;
  var widget = null;
  if (widgets.length) widget = widgets[0];
  return widget;
};

// can use alias (fieldName)
// even if `parentField` is provided, `field` is still a full path
var formatFieldName = exports.formatFieldName = function formatFieldName(field, config, meta) {
  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  if (!field) return;
  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};
  var fieldSeparator = config.settings.fieldSeparator;
  var fieldParts = (0, _configUtils.getFieldParts)(field, config);
  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
  if (options !== null && options !== void 0 && options.useTableName && fieldDef.tableName) {
    // legacy
    var fieldPartsCopy = (0, _toConsumableArray2["default"])(fieldParts);
    fieldPartsCopy[0] = fieldDef.tableName;
    fieldName = fieldPartsCopy.join(fieldSeparator);
  }
  if (fieldDef.fieldName) {
    fieldName = fieldDef.fieldName;
  }
  if (parentField) {
    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};
    var parentFieldName = parentField;
    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
      // fieldName = "#this." + fieldName; // ? for spel
    } else {
      if (fieldDef.fieldName) {
        // ignore
      } else {
        meta.errors.push("Can't cut group ".concat(parentFieldName, " from field ").concat(fieldName));
      }
    }
  }
  return fieldName;
};

/**
 * Used together with keepInputOnChangeFieldSrc
 */
var isEmptyItem = exports.isEmptyItem = function isEmptyItem(item, config) {
  var type = item.get("type");
  var mode = item.getIn(["properties", "mode"]);
  if (type == "rule_group" && mode == "array") {
    return isEmptyRuleGroupExt(item, config);
  } else if (type == "group" || type == "rule_group") {
    return isEmptyGroup(item, config);
  } else {
    return isEmptyRule(item, config);
  }
};
var isEmptyRuleGroupExt = function isEmptyRuleGroupExt(item, config) {
  var children = item.get("children1");
  var properties = item.get("properties");
  return isEmptyRuleGroupExtPropertiesAndChildren(properties.toObject(), children, config);
};

/**
 * Used to remove group ext without confirmation
 * 
 * If group operator is count, children can be empty.
 * If group operator is some/none/all, there should be at least one non-empty (even incomplete) child.
 */
var isEmptyRuleGroupExtPropertiesAndChildren = exports.isEmptyRuleGroupExtPropertiesAndChildren = function isEmptyRuleGroupExtPropertiesAndChildren(properties, children, config) {
  var _config$operators$ope, _config$operators$ope2;
  var operator = properties.operator;
  var cardinality = (_config$operators$ope = (_config$operators$ope2 = config.operators[operator]) === null || _config$operators$ope2 === void 0 ? void 0 : _config$operators$ope2.cardinality) !== null && _config$operators$ope !== void 0 ? _config$operators$ope : 1;
  var childrenAreRequired = cardinality == 0; // tip: for group operators some/none/all
  var filledParts = {
    group: !isEmptyRuleProperties(properties, config),
    children: !isEmptyGroupChildren(children, config)
  };
  var hasEnough = filledParts.group && (childrenAreRequired ? filledParts.children : true);
  return !hasEnough;
};
var isEmptyGroup = function isEmptyGroup(group, config) {
  var children = group.get("children1");
  return isEmptyGroupChildren(children, config);
};

/**
 * Used to remove group without confirmation
 * @returns {boolean} false if there is at least one (even incomplete) child
 */
var isEmptyGroupChildren = exports.isEmptyGroupChildren = function isEmptyGroupChildren(children, config) {
  var hasEnough = (children === null || children === void 0 ? void 0 : children.size) > 0 && children.filter(function (ch) {
    return !isEmptyItem(ch, config);
  }).size > 0;
  return !hasEnough;
};
var isEmptyRule = function isEmptyRule(rule, config) {
  var properties = rule.get("properties");
  return isEmptyRuleProperties((properties === null || properties === void 0 ? void 0 : properties.toObject()) || {}, config);
};

/**
 * Used to remove rule without confirmation
 * @param properties is an Object, but properties (like value) are Immutable
 * @returns {boolean} true if there is no enough data in rule
 */
var isEmptyRuleProperties = exports.isEmptyRuleProperties = function isEmptyRuleProperties(properties, config) {
  var liteCheck = true;
  var scoreThreshold = 3;
  var compl = whatRulePropertiesAreCompleted(properties, config, liteCheck);
  var hasEnough = compl.score >= scoreThreshold;
  return !hasEnough;
};

/**
 * Used to validate rule
 * @param properties is an Object, but its properties (like `value`) are Immutable
 * @param liteCheck true can be used to check that rule has enough data to ask confirmation before delete
 * @return {{parts: {field: boolean, operator: boolean, value: boolean}, score: number}}
 */
var whatRulePropertiesAreCompleted = exports.whatRulePropertiesAreCompleted = function whatRulePropertiesAreCompleted(_ref3, config) {
  var _config$operators$ope3, _config$operators$ope4, _value$filter;
  var field = _ref3.field,
    fieldSrc = _ref3.fieldSrc,
    fieldType = _ref3.fieldType,
    operator = _ref3.operator,
    value = _ref3.value,
    valueSrc = _ref3.valueSrc,
    valueType = _ref3.valueType;
  var liteCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cardinality = (_config$operators$ope3 = (_config$operators$ope4 = config.operators[operator]) === null || _config$operators$ope4 === void 0 ? void 0 : _config$operators$ope4.cardinality) !== null && _config$operators$ope3 !== void 0 ? _config$operators$ope3 : 1;
  var valueSrcs = valueSrc !== null && valueSrc !== void 0 && valueSrc.get ? valueSrc.toJS() : valueSrc;

  // tip: for liteCheck==true `score` should equal 3 if both LHS and RHS are at least partially filled
  var res = {
    parts: {},
    score: 0
  };
  res.parts.field = liteCheck ? field != null : isCompletedValue(field, fieldSrc, config);
  res.parts.operator = !!operator;
  res.parts.value = (value === null || value === void 0 || (_value$filter = value.filter(function (val, delta) {
    return isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta], config, liteCheck);
  })) === null || _value$filter === void 0 ? void 0 : _value$filter.size) >= (liteCheck ? Math.min(cardinality, 1) : cardinality);
  res.score = Object.keys(res.parts).filter(function (k) {
    return !!res.parts[k];
  }).length;
  if (liteCheck && res.score < 3) {
    // Boost score to confirm deletion:
    // - if RHS is empty, but LHS is a completed function
    // - if LHS is empty (only fieldType is set), but there is a completed function in RHS
    var deepCheck = true;
    if (!res.parts.value && fieldSrc === "func" && isCompletedValue(field, fieldSrc, config, false, deepCheck)) {
      res.score++;
    }
    if (!res.parts.field) {
      value === null || value === void 0 || value.map(function (val, delta) {
        if ((valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta]) === "func" && isCompletedValue(val, valueSrcs === null || valueSrcs === void 0 ? void 0 : valueSrcs[delta], config, false, deepCheck)) {
          res.score++;
        }
      });
    }
  }
  return res;
};
var isCompletedValue = function isCompletedValue(value, valueSrc, config) {
  var liteCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var deepCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  if (!liteCheck && valueSrc == "func" && value) {
    var _value$get;
    var funcKey = (_value$get = value.get) === null || _value$get === void 0 ? void 0 : _value$get.call(value, "func");
    var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);
    if (funcConfig) {
      var args = value.get("args");
      for (var argKey in funcConfig.args) {
        var argConfig = funcConfig.args[argKey];
        var argVal = args ? args.get(argKey) : undefined;
        // const argDef = getFieldConfig(config, argConfig);
        var argValue = argVal ? argVal.get("value") : undefined;
        var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
        if (argValue == undefined && (argConfig === null || argConfig === void 0 ? void 0 : argConfig.defaultValue) === undefined && !(argConfig !== null && argConfig !== void 0 && argConfig.isOptional)) {
          // arg is not completed
          return false;
        }
        if (argValue != undefined) {
          if (!isCompletedValue(argValue, argValueSrc, config, deepCheck ? liteCheck : true)) {
            // arg is complex and is not completed
            return false;
          }
        }
      }
      // all args are completed
      return true;
    }
  }
  return value != undefined;
};

/**
 * @param {*} value
 * @param {'value'|'field'|'func'} valueSrc
 * @param {object} config
 * @return {* | undefined}  undefined if func value is not complete (missing required arg vals); can return completed value != value
 */
var completeValue = exports.completeValue = function completeValue(value, valueSrc, config) {
  if (valueSrc == "func") return (0, _funcUtils.completeFuncValue)(value, config);else return value;
};

// item - Immutable
var getOneChildOrDescendant = exports.getOneChildOrDescendant = function getOneChildOrDescendant(item) {
  var children = item.get("children1");
  if ((children === null || children === void 0 ? void 0 : children.size) == 1) {
    var child = children.first();
    var childType = child.get("type");
    if (childType === "group") {
      return getOneChildOrDescendant(child);
    }
    return child;
  }
  return null;
};