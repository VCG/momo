"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extendConfig = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _uuid = _interopRequireDefault(require("./uuid"));
var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));
var _default = require("../config/default");
var _moment = _interopRequireDefault(require("moment"));
var _stuff = require("./stuff");
var _clone = _interopRequireDefault(require("clone"));
var _configSerialize = require("./configSerialize");
var _configUtils = require("./configUtils");
var _configMemo = require("./configMemo");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var extendConfig = exports.extendConfig = function extendConfig(config, configId) {
  var canCompile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  //operators, defaultOperator - merge
  //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget

  canCompile = canCompile && config.settings.useConfigCompress;

  // Already extended?
  if (config.__configId) {
    return config;
  }

  // Try to take from memo (cache)
  var cachedExtConfig = (0, _configMemo.findExtendedConfigInAllMemos)(config, canCompile);
  if (cachedExtConfig) {
    return cachedExtConfig;
  }
  var origConfig = config;

  // Clone (and compile if need)
  if (canCompile) {
    if (config.__compliled) {
      // already compiled
      config = (0, _clone["default"])(config);
    } else {
      // will be cloned and compiled
      config = (0, _configSerialize.compileConfig)(config);
    }
  } else {
    config = (0, _clone["default"])(config);
  }
  config.settings = (0, _mergeWith["default"])({}, _default.settings, config.settings, _stuff.mergeCustomizerNoArrays);
  config.__fieldsCntByType = {};
  config.__funcsCntByType = {};
  config.__fieldNames = {};
  extendTypesConfig(config.types, config);
  extendFieldsConfig(config.fields, config);
  extendFuncsConfig(config.funcs, config);
  var caseValueField = config.settings.caseValueField;
  if (caseValueField) {
    extendFieldConfig(caseValueField, config, [], false, true);
  }
  var momentLocale = config.settings.locale.moment;
  if (momentLocale) {
    _moment["default"].locale(momentLocale);
  }
  Object.defineProperty(config, "__configId", {
    enumerable: false,
    writable: false,
    value: configId || (0, _uuid["default"])()
  });
  config.__cache = {};
  (0, _stuff.deepFreeze)(config);

  // Save to memo (cache)
  var memo = (0, _configMemo.getCommonMemo)();
  memo.storeConfigPair(origConfig, config);
  return config;
};
function extendTypesConfig(typesConfig, config) {
  for (var type in typesConfig) {
    var typeConfig = typesConfig[type];
    extendTypeConfig(type, typeConfig, config);
  }
}
function extendTypeConfig(type, typeConfig, config) {
  var operators = null,
    defaultOperator = null;
  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {
    return w != "field" && w != "func";
  })[0];
  var excludeOperators = typeConfig.excludeOperators || [];
  for (var widget in typeConfig.widgets) {
    var typeWidgetConfig = typeConfig.widgets[widget];
    var defOp = typeWidgetConfig.defaultOperator;
    if (typeWidgetConfig.operators) {
      var typeWidgetOperators = typeWidgetConfig.operators.filter(function (op) {
        return !excludeOperators.includes(op);
      });
      operators = (0, _stuff.mergeArraysSmart)(operators, typeWidgetOperators);
    }
    if (defOp && !excludeOperators.includes(defOp)) {
      if (!defaultOperator || widget === typeConfig.mainWidget) {
        defaultOperator = defOp;
      }
    }
    if (widget == typeConfig.mainWidget) {
      typeWidgetConfig.widgetProps = _objectSpread(_objectSpread({}, typeConfig.mainWidgetProps || {}), typeWidgetConfig.widgetProps || {});
    }
    typeConfig.widgets[widget] = typeWidgetConfig;
  }
  if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);
  var _iterator = _createForOfIteratorHelper(typeConfig.valueSources),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var valueSrc = _step.value;
      if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
        typeConfig.widgets[valueSrc] = {};
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique
  if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;
}
function extendFieldsConfig(subconfig, config) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  for (var field in subconfig) {
    var fieldPathArr = [].concat((0, _toConsumableArray2["default"])(path), [field]);
    extendFieldConfig(subconfig[field], config, fieldPathArr);
    if (subconfig[field].subfields) {
      extendFieldsConfig(subconfig[field].subfields, config, fieldPathArr);
    }
  }
}
function extendFuncsConfig(subconfig, config) {
  var _config$settings;
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (!subconfig) return;
  var fieldSeparator = (config === null || config === void 0 || (_config$settings = config.settings) === null || _config$settings === void 0 ? void 0 : _config$settings.fieldSeparator) || ".";
  for (var funcKey in subconfig) {
    var funcPathArr = [].concat((0, _toConsumableArray2["default"])(path), [funcKey]);
    var funcPathStr = funcPathArr.join(fieldSeparator);
    var funcDef = subconfig[funcKey];
    if (funcDef.returnType) {
      funcDef.type = funcDef.returnType;
      if (!config.__funcsCntByType[funcDef.returnType]) config.__funcsCntByType[funcDef.returnType] = 0;
      config.__funcsCntByType[funcDef.returnType]++;
    }
    extendFieldConfig(funcDef, config, funcPathArr, false);
    if (funcDef.args) {
      for (var argKey in funcDef.args) {
        extendFieldConfig(funcDef.args[argKey], config, [].concat((0, _toConsumableArray2["default"])(funcPathArr), [argKey]), true);
      }
      // isOptional can be only in the end
      var argKeys = Object.keys(funcDef.args);
      var tmpIsOptional = true;
      var _iterator2 = _createForOfIteratorHelper(argKeys.reverse()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _argKey = _step2.value;
          var argDef = funcDef.args[_argKey];
          if (!tmpIsOptional && argDef.isOptional) {
            _stuff.logger.info("Arg ".concat(_argKey, " for func ").concat(funcPathStr, " can't be optional"));
            delete argDef.isOptional;
          }
          if (!argDef.isOptional) tmpIsOptional = false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    if (funcDef.subfields) {
      extendFuncsConfig(funcDef.subfields, config, [].concat((0, _toConsumableArray2["default"])(path), [funcKey]));
    }
  }
}
function normalizeFieldSettings(fieldConfig, config, type) {
  var _fieldConfig$fieldSet, _fieldConfig$fieldSet2;
  var keysToPutInFieldSettings = ["listValues", "treeValues", "allowCustomValues", "validateValue"];
  for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
    var k = _keysToPutInFieldSett[_i];
    if (fieldConfig[k]) {
      if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};
      fieldConfig.fieldSettings[k] = fieldConfig[k];
      delete fieldConfig[k];
    }
  }

  // normalize listValues
  if ((_fieldConfig$fieldSet = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet !== void 0 && _fieldConfig$fieldSet.listValues) {
    if (config.settings.normalizeListValues) {
      fieldConfig.fieldSettings.listValues = config.settings.normalizeListValues.call(config.ctx, fieldConfig.fieldSettings.listValues, type, fieldConfig.fieldSettings);
    }
  }
  // same for treeValues
  if ((_fieldConfig$fieldSet2 = fieldConfig.fieldSettings) !== null && _fieldConfig$fieldSet2 !== void 0 && _fieldConfig$fieldSet2.treeValues) {
    if (config.settings.normalizeListValues) {
      fieldConfig.fieldSettings.treeValues = config.settings.normalizeListValues.call(config.ctx, fieldConfig.fieldSettings.treeValues, type, fieldConfig.fieldSettings);
    }
  }
}
function extendFieldConfig(fieldConfig, config) {
  var _fieldSeparator;
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var isFuncArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var isCaseValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var _config$settings2 = config.settings,
    showLabels = _config$settings2.showLabels,
    fieldSeparator = _config$settings2.fieldSeparator;
  fieldSeparator = (_fieldSeparator = fieldSeparator) !== null && _fieldSeparator !== void 0 ? _fieldSeparator : ".";
  var argKey = path[path.length - 1];
  var funcKey = isFuncArg ? path.slice(0, path.length - 1).join(fieldSeparator) : path.join(fieldSeparator);
  var isFunc = !!fieldConfig.returnType;
  var type = fieldConfig.type || fieldConfig.returnType;
  // const isGroup = type === "!struct" || type === "!group";
  var typeConfig = config.types[type];
  var excludeOperatorsForField = fieldConfig.excludeOperators || [];
  var operators = (fieldConfig.operators || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.operators) || []).filter(function (op) {
    return !excludeOperatorsForField.includes(op);
  });
  var defaultOperator = fieldConfig.defaultOperator || (typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.defaultOperator);
  if (excludeOperatorsForField.includes(defaultOperator)) defaultOperator = undefined;
  var hasOwnDefaultOperator = !!defaultOperator && defaultOperator == fieldConfig.defaultOperator;
  if (hasOwnDefaultOperator) {
    fieldConfig.ownDefaultOperator = fieldConfig.defaultOperator;
  }
  if (!typeConfig) {
    // console.warn(`No type config for ${type}`);
    fieldConfig.disabled = true;
    return;
  }
  if (!isFuncArg && !isFunc && !isCaseValue) {
    if (!config.__fieldsCntByType[type]) config.__fieldsCntByType[type] = 0;
    config.__fieldsCntByType[type]++;
  }
  if (isFuncArg) {
    fieldConfig._isFuncArg = true;
    fieldConfig._argKey = argKey;
    fieldConfig._funcKey = funcKey;
  }
  if (isFunc) {
    fieldConfig._isFunc = true;
    fieldConfig._funcKey = funcKey;
  }
  if (isCaseValue) {
    fieldConfig._isCaseValue = true;
  }
  normalizeFieldSettings(fieldConfig, config, type);

  // copy from type to field
  var excludeKeysFromType = ["widgets", "operators", "defaultOperator"];
  Object.keys(typeConfig).filter(function (k) {
    return !excludeKeysFromType.includes(k);
  }).map(function (k) {
    if (!fieldConfig[k]) {
      fieldConfig[k] = (0, _stuff.shallowCopy)(typeConfig[k]);
    }
  });

  // copy/merge widgets
  var excludeOperatorsForType = typeConfig.excludeOperators || [];
  if (fieldConfig.operators) {
    // `operators` from field can override `excludeOperators` from type, see `prox1` at examples
    excludeOperatorsForType = excludeOperatorsForType.filter(function (op) {
      return !fieldConfig.operators.includes(op);
    });
  }
  if (!fieldConfig.widgets) fieldConfig.widgets = {};
  var _loop = function _loop() {
    var fieldWidgetConfig = _objectSpread({}, fieldConfig.widgets[widget] || {});
    var typeWidgetConfig = typeConfig.widgets[widget] || {};

    // merge operators, defaultOperator
    if (!isFuncArg) {
      // tip: operators are not used for func args
      var defOp = fieldWidgetConfig.defaultOperator;
      var excludeOperators = [].concat((0, _toConsumableArray2["default"])(excludeOperatorsForField), (0, _toConsumableArray2["default"])(excludeOperatorsForType));
      var shouldIncludeOperators = fieldConfig.preferWidgets && (widget === "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
      if (fieldWidgetConfig.operators) {
        var addOperators = fieldWidgetConfig.operators.filter(function (op) {
          return !excludeOperators.includes(op);
        });
        fieldWidgetConfig.operators = addOperators;
        // operators = [...(operators || []), ...addOperators];
        operators = (0, _stuff.mergeArraysSmart)(operators, addOperators);
      } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
        var _addOperators = typeWidgetConfig.operators.filter(function (op) {
          return !excludeOperators.includes(op);
        });
        fieldWidgetConfig.operators = _addOperators;
        // operators = [...(operators || []), ...addOperators];
        operators = (0, _stuff.mergeArraysSmart)(operators, _addOperators);
      }
      if (defOp && !excludeOperators.includes(defOp)) {
        if (!defaultOperator || !hasOwnDefaultOperator && widget === fieldConfig.mainWidget) {
          // tip: defOp can overwrite default operator from type config
          defaultOperator = defOp;
        }
      }
    }

    // merge widgetProps
    if (widget === fieldConfig.mainWidget) {
      fieldWidgetConfig.widgetProps = _objectSpread(_objectSpread(_objectSpread({}, typeWidgetConfig.widgetProps || {}), fieldConfig.mainWidgetProps || {}), fieldWidgetConfig.widgetProps || {});
    } else {
      fieldWidgetConfig.widgetProps = _objectSpread(_objectSpread({}, typeWidgetConfig.widgetProps || {}), fieldWidgetConfig.widgetProps || {});
    }

    // merge opProps
    var opKeys = Array.from(new Set([].concat((0, _toConsumableArray2["default"])(Object.keys(typeWidgetConfig.opProps || {})), (0, _toConsumableArray2["default"])(Object.keys(fieldWidgetConfig.opProps || {})))));
    if (opKeys.length) {
      var opProps = {};
      var _iterator3 = _createForOfIteratorHelper(opKeys),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _typeWidgetConfig$opP, _fieldWidgetConfig$op;
          var op = _step3.value;
          opProps[op] = _objectSpread(_objectSpread({}, ((_typeWidgetConfig$opP = typeWidgetConfig.opProps) === null || _typeWidgetConfig$opP === void 0 ? void 0 : _typeWidgetConfig$opP[op]) || {}), ((_fieldWidgetConfig$op = fieldWidgetConfig.opProps) === null || _fieldWidgetConfig$op === void 0 ? void 0 : _fieldWidgetConfig$op[op]) || {});
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      fieldWidgetConfig.opProps = opProps;
    }

    // label for func arg
    var _fieldWidgetConfig = fieldWidgetConfig,
      valueLabel = _fieldWidgetConfig.valueLabel,
      valuePlaceholder = _fieldWidgetConfig.valuePlaceholder;
    if (isFuncArg) {
      if (!valueLabel) fieldWidgetConfig.valueLabel = fieldConfig.label || argKey;
      if (!valuePlaceholder && !showLabels) fieldWidgetConfig.valuePlaceholder = fieldConfig.label || argKey;
    }

    // copy other widget configs from type to field
    fieldWidgetConfig = _objectSpread(_objectSpread({}, typeWidgetConfig), fieldWidgetConfig);
    fieldConfig.widgets[widget] = fieldWidgetConfig;
  };
  for (var widget in typeConfig.widgets) {
    _loop();
  }
  if (!isFuncArg) {
    // tip: operators are not used for func args
    if (!fieldConfig.operators) {
      fieldConfig.operators = Array.from(new Set(operators)); // unique
    }
    if (!fieldConfig.defaultOperator) {
      fieldConfig.defaultOperator = defaultOperator;
    }
  }
  if (!isFuncArg && !isFunc && !isCaseValue) {
    var _computeFieldName = computeFieldName(config, path),
      fieldName = _computeFieldName.fieldName,
      inGroup = _computeFieldName.inGroup;
    if (fieldName) {
      fieldConfig.fieldName = fieldName;
      if (!config.__fieldNames[fieldName]) config.__fieldNames[fieldName] = [];
      config.__fieldNames[fieldName].push({
        fullPath: path,
        inGroup: inGroup
      });
    }
  }
}
function computeFieldName(config, path) {
  if (!path) return {};
  var fieldSeparator = config.settings.fieldSeparator;
  var _reduce = (0, _toConsumableArray2["default"])(path).reduce(function (_ref, f, i, arr) {
      var computedPath = _ref.computedPath,
        computed = _ref.computed,
        inGroup = _ref.inGroup;
      var fullPath = [].concat((0, _toConsumableArray2["default"])(arr.slice(0, i)), [f]);
      var fConfig = (0, _configUtils.getFieldRawConfig)(config, fullPath);
      if ((fConfig === null || fConfig === void 0 ? void 0 : fConfig.type) === "!group" && i < arr.length - 1) {
        // don't include group in final field name
        inGroup = fullPath.join(fieldSeparator);
        computedPath = [];
      } else if (fConfig !== null && fConfig !== void 0 && fConfig.fieldName) {
        // tip: fieldName overrides path !
        computed = true;
        computedPath = [fConfig.fieldName];
      } else {
        computedPath = [].concat((0, _toConsumableArray2["default"])(computedPath), [f]);
      }
      return {
        computedPath: computedPath,
        computed: computed,
        inGroup: inGroup
      };
    }, {
      computedPath: [],
      computed: false,
      inGroup: undefined
    }),
    computedPath = _reduce.computedPath,
    computed = _reduce.computed,
    inGroup = _reduce.inGroup;
  return computed ? {
    fieldName: computedPath.join(fieldSeparator),
    inGroup: inGroup
  } : {};
}