"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _react = _interopRequireWildcard(require("react"));
require("./SketchPanel.css");
var _QueryBuilder = _interopRequireDefault(require("./QueryBuilder"));
var _CircleTwoTone = _interopRequireDefault(require("@mui/icons-material/CircleTwoTone"));
var _ArrowRightAlt = _interopRequireDefault(require("@mui/icons-material/ArrowRightAlt"));
var _Edit = _interopRequireDefault(require("@mui/icons-material/Edit"));
var _Delete = _interopRequireDefault(require("@mui/icons-material/Delete"));
var _Info = _interopRequireDefault(require("@mui/icons-material/Info"));
var _paper = _interopRequireDefault(require("paper"));
var _GlobalContext = require("../contexts/GlobalContext");
var _lodash = _interopRequireDefault(require("lodash"));
var _material = require("@mui/material");
var _reactFontawesome = require("@fortawesome/react-fontawesome");
var _freeSolidSvgIcons = require("@fortawesome/free-solid-svg-icons");
var _mui = require("@react-awesome-query-builder/mui");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var InitialConfig = _mui.MuiConfig;
delete InitialConfig["conjunctions"]["OR"];
InitialConfig["settings"]["showNot"] = false;
InitialConfig["settings"]["groupOperators"] = false;
InitialConfig["settings"]["canAddGroup"] = false;
InitialConfig["settings"]["canReorder"] = false;
InitialConfig["settings"]["renderSize"] = "small";
InitialConfig["settings"]["setOpOnChangeField"] = ["keep", "first"];
function SketchPanel(props) {
  var attributes = props.attributes;
  var sketchPanelId = "sketch-panel";
  var _useState = (0, _react.useState)([]),
    _useState2 = _slicedToArray(_useState, 2),
    nodes = _useState2[0],
    setNodes = _useState2[1];
  var _useState3 = (0, _react.useState)([]),
    _useState4 = _slicedToArray(_useState3, 2),
    nodeLabels = _useState4[0],
    setNodeLabels = _useState4[1];
  var _useState5 = (0, _react.useState)([]),
    _useState6 = _slicedToArray(_useState5, 2),
    edges = _useState6[0],
    setEdges = _useState6[1];
  var _useState7 = (0, _react.useState)(null),
    _useState8 = _slicedToArray(_useState7, 2),
    importData = _useState8[0],
    setImportData = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState10 = _slicedToArray(_useState9, 2),
    nodeImportUpdate = _useState10[0],
    setNodeImportUpdate = _useState10[1];
  var _useState11 = (0, _react.useState)(false),
    _useState12 = _slicedToArray(_useState11, 2),
    edgeImportUpdate = _useState12[0],
    setEdgeImportUpdate = _useState12[1];
  // States are node (add nodes), edge (add edges), edit(change node/edge properties)
  var _useState13 = (0, _react.useState)("node"),
    _useState14 = _slicedToArray(_useState13, 2),
    mouseState = _useState14[0],
    setMouseState = _useState14[1];
  var _useState15 = (0, _react.useState)(false),
    _useState16 = _slicedToArray(_useState15, 2),
    showInfo = _useState16[0],
    setShowInfo = _useState16[1];
  var _useState17 = (0, _react.useState)("crosshair"),
    _useState18 = _slicedToArray(_useState17, 2),
    cursor = _useState18[0],
    setCursor = _useState18[1];
  var _useState19 = (0, _react.useState)(),
    _useState20 = _slicedToArray(_useState19, 2),
    pencil = _useState20[0],
    setPencil = _useState20[1];
  // Checks for mouse intersections
  var _useState21 = (0, _react.useState)(),
    _useState22 = _slicedToArray(_useState21, 2),
    testCircle = _useState22[0],
    setTestCircle = _useState22[1];
  // Edit properties with boolean query builder
  var _React$useState = _react["default"].useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    popperLocation = _React$useState2[0],
    setPopperLocation = _React$useState2[1];
  var _React$useState3 = _react["default"].useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    showPopper = _React$useState4[0],
    setShowPopper = _React$useState4[1];
  var circleRadius = 20;
  var currentPath;
  var currentNode;
  var currentSelection;
  var _useState23 = (0, _react.useState)({}),
    _useState24 = _slicedToArray(_useState23, 2),
    canvasDimension = _useState24[0],
    setCanvasDimension = _useState24[1];
  var _useState25 = (0, _react.useState)(null),
    _useState26 = _slicedToArray(_useState25, 2),
    NodeFields = _useState26[0],
    setNodeFields = _useState26[1];
  var _useState27 = (0, _react.useState)(null),
    _useState28 = _slicedToArray(_useState27, 2),
    EdgeFields = _useState28[0],
    setEdgeFields = _useState28[1];

  // We track the overall motif in the global context
  var context = (0, _react.useContext)(_GlobalContext.AppContext);
  var calculateNewPosition = function calculateNewPosition(dimension, position) {
    var newX = canvasDimension.width / dimension.width * position[1];
    var newY = canvasDimension.height / dimension.height * position[2];
    return [Math.floor(newX), Math.floor(newY)];
  };
  var getPositionTransformedData = function getPositionTransformedData(data) {
    var newNodes = data.nodes.map(function (node) {
      var _calculateNewPosition = calculateNewPosition(data.dimension, node.position),
        _calculateNewPosition2 = _slicedToArray(_calculateNewPosition, 2),
        newX = _calculateNewPosition2[0],
        newY = _calculateNewPosition2[1];
      return _objectSpread(_objectSpread({}, node), {}, {
        position: ["Point", newX, newY]
      });
    });
    var newData = _objectSpread(_objectSpread({}, data), {}, {
      nodes: newNodes,
      dimension: canvasDimension
    });
    return newData;
  };
  var importMotif = function importMotif() {
    console.log("importing motif");
    clearSketch(); // clear sketch
    // import file using file picker
    var fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.onchange = function (e) {
      var file = e.target.files[0];
      // parse file to object
      var reader = new FileReader();
      reader.readAsText(file, "UTF-8");
      reader.onload = function (e) {
        var data = JSON.parse(e.target.result);
        var newData = getPositionTransformedData(data);
        setImportData(newData);
        setNodeImportUpdate(true);
      };
    };
    fileInput.click();
  };
  var exportMotif = function exportMotif() {
    console.log("exporting motif");
    console.log(nodes);
    console.log(edges);
    var out = getEncodedMotif(nodes, edges);
    // download out as JSON file
    var json = JSON.stringify(out);
    var blob = new Blob([json], {
      type: "application/json"
    });
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = "motif.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  var clearSketch = function clearSketch() {
    var _paper$project, _paper$view;
    console.log("Clearing");
    _paper["default"] === null || _paper["default"] === void 0 || (_paper$project = _paper["default"].project) === null || _paper$project === void 0 || (_paper$project = _paper$project.activeLayer) === null || _paper$project === void 0 || _paper$project.removeChildren();
    _paper["default"] === null || _paper["default"] === void 0 || (_paper$view = _paper["default"].view) === null || _paper$view === void 0 || _paper$view.draw();
    // Remove all edges and nodes
    setNodes([]);
    setEdges([]);
  };
  var deleteSketchElement = function deleteSketchElement() {
    // edges
    if (context.selectedSketchElement && context.selectedSketchElement.type === "edge") {
      var _context$selectedSket;
      var newEdges = edges.filter(function (edge) {
        return edge.label !== context.selectedSketchElement.label;
      });
      context.selectedSketchElement.edgeLine.remove();
      context.selectedSketchElement.lineGroup.remove();
      (_context$selectedSket = context.selectedSketchElement.propertyLabel) === null || _context$selectedSket === void 0 || _context$selectedSket.remove();
      context.setSelectedSketchElement(null);
      setEdges(newEdges);
    }
    // nodes
    if (context.selectedSketchElement && context.selectedSketchElement.type === "node") {
      // find adjacent edges
      var nodeLabel = context.selectedSketchElement.label;
      var adjacentEdges = edges.filter(function (edge) {
        if (edge.fromNode.label === nodeLabel || edge.toNode.label === nodeLabel) {
          return edge;
        }
      });

      // delete edges from canvas
      adjacentEdges.map(function (edge) {
        var _edge$propertyLabel;
        edge.edgeLine.remove();
        edge.lineGroup.remove();
        (_edge$propertyLabel = edge.propertyLabel) === null || _edge$propertyLabel === void 0 || _edge$propertyLabel.remove();
      });

      // delete node from canvas
      var selectedNodeLabel = context.selectedSketchElement.label;
      context.selectedSketchElement.circle.remove();
      context.selectedSketchElement.circleGroup.remove();
      context.setSelectedSketchElement(null);

      // delete node and rename remaining nodes
      var newNodes = nodes.filter(function (node) {
        return node.label !== selectedNodeLabel;
      }).map(function (node, i) {
        return renameCircle(node.circle, i, node.properties, "tree" in node ? node.tree : null, node.label);
      });
      var getNewNode = function getNewNode(previousLabel) {
        return newNodes.find(function (node) {
          return node.previousLabel === previousLabel;
        });
      };

      // delete adjacent edges
      var _newEdges = edges.filter(function (edge) {
        return !adjacentEdges.includes(edge);
      }).map(function (edge) {
        var newFromNode = getNewNode(edge.fromNode.label);
        var newToNode = getNewNode(edge.toNode.label);
        var newNodeIndices = [_lodash["default"].findLastIndex(newNodes, newFromNode), _lodash["default"].findLastIndex(newNodes, newToNode)];
        return renameEdge(newFromNode, newToNode, newNodeIndices, edge);
      });

      // reset edges and nodes
      setEdges(_newEdges);
      setNodes(newNodes);
    }
  };
  var renameEdge = function renameEdge(fromNode, toNode, nodeIndices, edge) {
    var tree = "tree" in edge ? edge.tree : null;
    var edgeObj = _objectSpread({}, edge);
    edgeObj["fromNode"] = fromNode;
    edgeObj["toNode"] = toNode;
    edgeObj["indices"] = nodeIndices;
    edgeObj["label"] = "".concat(fromNode.label, " -> ").concat(toNode.label);
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    return edgeObj;
  };
  var renameCircle = function renameCircle(circle, index) {
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var previousLabel = arguments.length > 4 ? arguments[4] : undefined;
    circle.fillColor = context.neuronColors[index];
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper["default"].PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 20
    });
    var letter = String.fromCharCode(65 + index);
    label.content = letter;
    var circleGroup = new _paper["default"].Group([circle, label]);
    if (tree !== null) {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup,
        tree: _mui.Utils.loadTree(tree)
      };
    } else {
      return {
        circle: circle,
        label: letter,
        previousLabel: previousLabel,
        properties: properties,
        type: "node",
        circleGroup: circleGroup
      };
    }
  };
  var addCircle = function addCircle(point, node) {
    // add circle to paper
    var circle = new _paper["default"].Path.Circle(point, circleRadius);
    circle.strokeColor = "#000000";
    circle.strokeWidth = 3;
    circle.fillColor = context.neuronColors[node.index];
    circle.opacity = 1.0;
    circle.position = point;
    placeCircle(circle, node.label, node.properties, "tree" in node ? node.tree : null);
  };
  var placeCircle = function placeCircle(circle, letter) {
    var _currentPath;
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var tree = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    circle.opacity = 1;
    var textPoint = [circle.position.x, circle.position.y + 7];
    var label = new _paper["default"].PointText({
      point: textPoint,
      justification: "center",
      fillColor: "white",
      font: "Roboto",
      fontSize: 20
    });
    label.content = letter;
    (_currentPath = currentPath) === null || _currentPath === void 0 || _currentPath.remove();
    currentPath = null;
    var circleGroup = new _paper["default"].Group([circle, label]);
    if (tree !== null) {
      setNodes(function (nodes) {
        return [].concat(_toConsumableArray(nodes), [{
          circle: circle,
          label: letter,
          properties: properties,
          type: "node",
          circleGroup: circleGroup,
          tree: _mui.Utils.loadTree(tree)
        }]);
      });
    } else {
      setNodes(function (nodes) {
        return [].concat(_toConsumableArray(nodes), [{
          circle: circle,
          label: letter,
          properties: properties,
          type: "node",
          circleGroup: circleGroup
        }]);
      });
    }
  };
  var bindPencilEvents = function bindPencilEvents() {
    currentPath = null;
    pencil.onMouseMove = function (event) {
      var point = new _paper["default"].Point(event.point);
      testCircle.position = point;
      if (mouseState === "node") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
        var color = numNodes <= context.neuronColors.length ? context.neuronColors[numNodes] : "#000000";
        // Create new Circle
        if (!currentPath) {
          currentPath = new _paper["default"].Path.Circle(point, circleRadius);
          currentPath.strokeColor = "#000000";
          currentPath.strokeWidth = 3;
          currentPath.fillColor = color;
          currentPath.opacity = 0.5;
        } else {
          // Move existing circle
          currentPath.position = point;
        }
      } else if (mouseState === "edge") {
        if (context.selectedSketchElement) context.setSelectedSketchElement(null);
        if (!currentPath) {
          currentPath = new _paper["default"].Path();
          currentPath.strokeColor = "#000000";
          currentPath.strokeWidth = 3;
          currentPath.opacity = 0.5;
          currentPath.add([point.x - 10, point.y]);
          currentPath.add([point.x + 10, point.y]);
        }
        var intersections = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Starting Point of Edge
        if (intersections === -1 && currentNode) {
          currentPath.segments[0].point = currentNode.circle.getNearestPoint(point);
          currentPath.segments[1].point = point;
        } //    Ending Point of Edge
        else if (intersections !== -1 && currentNode && !_lodash["default"].isEqual(currentNode, nodes[intersections])) {
          currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[intersections].circle.position);
          currentPath.segments[1].point = nodes[intersections].circle.getNearestPoint(currentNode.circle.position);
        } // Otherwise move the line glyph
        else {
          currentPath.segments[0].point = new _paper["default"].Point([point.x - 10, point.y]);
          currentPath.segments[1].point = new _paper["default"].Point([point.x + 10, point.y]);
        }
      } else if (mouseState === "edit") {
        // Check with intersections with nodes
        var _intersections = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Check with intersections with nodes
        if (_intersections !== -1) {
          currentSelection = nodes[_intersections];
          return;
        }
        // Check with intersections with edges
        _intersections = _lodash["default"].findLastIndex(edges.map(function (e) {
          return !_lodash["default"].isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        if (_intersections !== -1) {
          currentSelection = edges[_intersections];
          return;
        }
        currentSelection = null;
      } else if (mouseState === "move") {
        var _intersections2 = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Check with intersections with nodes
        if (_intersections2 !== -1) {
          currentSelection = nodes[_intersections2];
          nodes[_intersections2].circle.selected = true;
        } else {
          currentSelection = null;
          _paper["default"].project.activeLayer.selected = false;
        }
      }
    };
    pencil.onMouseDown = function (event) {
      var point = new _paper["default"].Point(event.point);
      if (mouseState === "node") {
        if (!currentPath) return;
        // Create new node
        var numNodes = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0;
        var letter = String.fromCharCode(65 + numNodes);
        var circle = currentPath.clone();
        placeCircle(circle, letter);
      } else if (mouseState === "edge") {
        var _currentPath2;
        var intersections = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        if (intersections !== -1 && !currentNode && currentPath) {
          currentNode = nodes[intersections];
          currentPath.segments[0].position = currentNode.circle.getNearestPoint(point);
          return;
        } else if (currentPath && intersections !== -1) {
          if (!_lodash["default"].isEqual(currentNode, nodes[intersections])) {
            // If line intersects with two nodes, draw edge
            currentPath.segments[0].point = currentNode.circle.getNearestPoint(nodes[intersections].circle.position);
            currentPath.segments[1].point = nodes[intersections].circle.getNearestPoint(currentNode.circle.position);
            var edge = currentPath.clone();
            edge.opacity = 1;
            addEdge(currentNode, nodes[intersections], edge);
          }
        }
        (_currentPath2 = currentPath) === null || _currentPath2 === void 0 || _currentPath2.remove();
        currentNode = null;
        currentPath = null;
      } else if (mouseState === "edit") {
        var nodeIntersections = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        var edgeIntersections = _lodash["default"].findLastIndex(edges.map(function (e) {
          return !_lodash["default"].isEmpty(testCircle === null || testCircle === void 0 ? void 0 : testCircle.getIntersections(e.edgeLine));
        }), function (e) {
          return e === true;
        });
        // select the clicked on element and show the popper
        if (nodeIntersections !== -1 || edgeIntersections !== -1) {
          var _currentSelection, _currentSelection2;
          context.setSelectedSketchElement(currentSelection);
          var selectedElement = ((_currentSelection = currentSelection) === null || _currentSelection === void 0 ? void 0 : _currentSelection.lineGroup) || ((_currentSelection2 = currentSelection) === null || _currentSelection2 === void 0 ? void 0 : _currentSelection2.circle);
          _paper["default"].project.activeLayer.selected = false;
          selectedElement.selected = true;
          setShowPopper(true);
        } else {
          // If they click out, make the popper go away
          setShowPopper(false);
          context.setSelectedSketchElement(null);
          setPopperLocation(null);
        }
      } else if (mouseState === "move") {
        var _intersections3 = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Check with intersections with nodes
        if (_intersections3 !== -1) {
          currentSelection = nodes[_intersections3];
        }
        if (currentSelection) {
          setCursor("grabbing");
        }
      }
    };
    pencil.onMouseUp = function (event) {
      if (mouseState === "move") {
        console.log("grab", currentNode);
        var nodeIndex = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.label === currentNode.label;
        }));
        // // list of edges including this edge
        var tmpEdges = _lodash["default"].clone(edges);
        var edgesToAddAgain = [];
        var filteredEdges = tmpEdges.filter(function (e) {
          if (e.indices.includes(nodeIndex)) {
            edgesToAddAgain.push(e);
            return false;
          }
          return true;
        });
        var newEdges = edgesToAddAgain.map(function (e) {
          e.edgeLine.opacity = 1;
          return createEdge(e.fromNode, e.toNode, e.edgeLine, e.indices, e.properties, e.tree, e.propertyLabel);
        });
        setEdges([].concat(_toConsumableArray(newEdges), _toConsumableArray(filteredEdges)));
        setCursor("grab");
      }
    };
    pencil.onMouseDrag = function (event) {
      if (mouseState === "move") {
        nodeLabels.forEach(function (label) {
          label === null || label === void 0 || label.remove();
        });
        var intersections = _lodash["default"].findLastIndex(nodes.map(function (n) {
          return n.circle.contains(event.point);
        }), function (e) {
          return e === true;
        });
        // Check with intersections with nodes
        if (intersections === -1) return;
        nodes[intersections].circleGroup.position = new _paper["default"].Point(event.point);
        currentNode = nodes[intersections];
        edges.forEach(function (e, i) {
          if (e.indices.includes(intersections)) {
            if (e.lineGroup) {
              var _edges$i$propertyLabe;
              edges[i].edgeLine.remove();
              edges[i].lineGroup.remove();
              (_edges$i$propertyLabe = edges[i].propertyLabel) === null || _edges$i$propertyLabe === void 0 || _edges$i$propertyLabe.remove();
              edges[i].edgeLine = null;
              edges[i].edgeLine = null;
              edges[i].oppositeEdge = null;
              edges[i].edgeLine = new _paper["default"].Path();
              edges[i].edgeLine.strokeColor = "#000000";
              edges[i].edgeLine.strokeWidth = 3;
              edges[i].edgeLine.opacity = 0.5;
              edges[i].edgeLine.add([0, 0]);
              edges[i].edgeLine.add([0, 0]);
            }
            edges[i].edgeLine.segments[0].point = nodes[e.indices[0]].circle.getNearestPoint(nodes[e.indices[1]].circle.position);
            edges[i].edgeLine.segments[1].point = nodes[e.indices[1]].circle.getNearestPoint(nodes[e.indices[0]].circle.position);
          }
        });
      }
    };
  };
  var addEdge = function addEdge(fromNode, toNode, edgeLine) {
    var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var tree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var addEdgeImmediately = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var nodeIndices = [_lodash["default"].findLastIndex(nodes, fromNode), _lodash["default"].findLastIndex(nodes, toNode)];
    var matchingEdge = _lodash["default"].findIndex(edges, function (e) {
      return _lodash["default"].isEqual(e.indices, nodeIndices);
    });
    if (matchingEdge !== -1) {
      console.log("Edge Exists");
      edgeLine.remove();
      return;
    }
    var newEdgeObj = createEdge(fromNode, toNode, edgeLine, nodeIndices, properties, tree);
    addEdgePropertyLabel(newEdgeObj);
    if (addEdgeImmediately) {
      setEdges([].concat(_toConsumableArray(edges), [newEdgeObj]));
    }
    return newEdgeObj;
  };
  var addExistEdges = function addExistEdges(newEdges) {
    var output = [];
    newEdges.map(function (edge) {
      var path = new _paper["default"].Path();
      path.strokeColor = "#000000";
      path.strokeWidth = 3;
      path.opacity = 1.0;
      path.add([edge.fromNode.circle.position[1], edge.fromNode.circle.position[2]]);
      path.add([edge.toNode.circle.position[1], edge.toNode.circle.position[2]]);
      var startNode = nodes[edge.indices[0]];
      var endNode = nodes[edge.indices[1]];
      path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
      path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
      var tree = "tree" in edge ? edge.tree : null;
      var _newEdge = createEdge(startNode, endNode, path, edge.indices, edge.properties, tree);
      output.push(_newEdge);
    });
    setEdges([].concat(output));
  };
  var createEdge = function createEdge(fromNode, toNode, edgeLine, nodeIndices) {
    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var tree = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var propertyLabel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var edgeObj = {
      indices: nodeIndices,
      toNode: toNode,
      fromNode: fromNode,
      edgeLine: edgeLine
    };
    // If this edge already exists, don't create it
    // Checks from an edge going the opposite direction between the same two nodes
    var origToPoint = _lodash["default"].cloneDeep(edgeLine.segments[0].point);
    var circ = new _paper["default"].Path.Circle(origToPoint, 8);
    var toPoint = edgeLine.segments[0].point = circ.getIntersections(edgeLine)[0].point;
    circ.remove();
    var origFromPoint = _lodash["default"].cloneDeep(edgeLine.segments[1].point);
    circ = new _paper["default"].Path.Circle(origFromPoint, 8);
    var fromPoint = edgeLine.segments[1].point = circ.getIntersections(edgeLine)[0].point;
    var dy = toPoint.y - fromPoint.y;
    var dx = toPoint.x - fromPoint.x;
    var theta = Math.atan2(dy, dx); // range (-PI, PI]
    var newY = 7 * Math.sin(theta) + fromPoint.y;
    var newX = 7 * Math.cos(theta) + fromPoint.x;
    var circle = new _paper["default"].Path.Circle([newX, newY], 7);
    // Check where the arrow head points should be
    var secondCircle = new _paper["default"].Path.Circle(circle.getNearestPoint(toPoint), 7);
    var intersections = secondCircle.getIntersections(circle).map(function (intersection) {
      return intersection.point;
    });
    intersections.splice(1, 0, fromPoint);
    var trianglePath = new _paper["default"].Path(intersections);
    trianglePath.strokeColor = "black";
    trianglePath.strokeWidth = 3;
    trianglePath.strokeJoin = "round";
    // Create a big group with line and arrow
    edgeObj["toPoint"] = toPoint;
    edgeObj["fromPoint"] = fromPoint;
    edgeObj["lineGroup"] = new _paper["default"].Group([trianglePath, edgeObj.edgeLine]);
    secondCircle === null || secondCircle === void 0 || secondCircle.remove();
    circle === null || circle === void 0 || circle.remove();
    edgeObj["type"] = "edge";
    edgeObj["label"] = "".concat(edgeObj.fromNode.label, " -> ").concat(edgeObj.toNode.label);
    edgeObj["properties"] = properties;
    if (tree !== null) {
      edgeObj["tree"] = _mui.Utils.loadTree(tree);
    } else {
      edgeObj["tree"] = tree;
    }
    if (propertyLabel) edgeObj = addEdgePropertyLabel(edgeObj);
    return edgeObj;
  };
  var addEdgePropertyLabel = function addEdgePropertyLabel(e) {
    var _e$propertyLabel;
    // Remove any existing label
    if (!e.properties) return e;
    (_e$propertyLabel = e.propertyLabel) === null || _e$propertyLabel === void 0 || _e$propertyLabel.remove();
    var midpoint = new _paper["default"].Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
    var midpointCircle = new _paper["default"].Path.Circle(midpoint, 10);
    var intersectionsCircles = midpointCircle.getIntersections(e.lineGroup.children[1]).map(function (i) {
      return new _paper["default"].Path.Circle(i.point, 15);
    });
    var drawPoints = intersectionsCircles[0].getIntersections(intersectionsCircles[1]).map(function (i) {
      return i.point;
    });
    var topPoint = _lodash["default"].sortBy(drawPoints, "y")[0];
    midpointCircle.remove();
    intersectionsCircles.map(function (i) {
      return i.remove();
    });
    var labelText = "";
    if ("weight" in e.properties) {
      if (_lodash["default"].isNumber(e.properties.weight)) {
        labelText = e.properties.weight;
      } else if (e.properties.weight["$lt"]) {
        labelText = "< " + e.properties.weight["$lt"];
      } else if (e.properties.weight["$gt"]) {
        labelText = "> " + e.properties.weight["$gt"];
      }
    }
    var propertyLabel = new _paper["default"].PointText({
      point: topPoint,
      justification: "center",
      fillColor: "black",
      font: "Roboto",
      fontSize: 14
    });
    propertyLabel.content = labelText;
    e.propertyLabel = propertyLabel;
    return e;
  };
  (0, _react.useEffect)(function () {
    if (importData && nodeImportUpdate) {
      importData.nodes.forEach(function (node) {
        var point = new _paper["default"].Point(node.position[1], node.position[2]);
        addCircle(point, node);
      });
      setNodeImportUpdate(false);
      setEdgeImportUpdate(true);
    }
  }, [nodeImportUpdate]);
  (0, _react.useEffect)(function () {
    if (importData && edgeImportUpdate) {
      var newEdges = [];
      try {
        importData.edges.forEach(function (edge) {
          var myInputStartNode = importData.nodes.find(function (node) {
            return node.index === edge.indices[0];
          });
          var myInputEndNode = importData.nodes.find(function (node) {
            return node.index === edge.indices[1];
          });
          var path = new _paper["default"].Path();
          path.strokeColor = "#000000";
          path.strokeWidth = 3;
          path.opacity = 1.0;
          path.add([myInputStartNode.position[1], myInputStartNode.position[2]]);
          path.add([myInputEndNode.position[1], myInputEndNode.position[2]]);
          var startNode = nodes[edge.indices[0]];
          var endNode = nodes[edge.indices[1]];
          path.segments[0].point = startNode.circle.getNearestPoint(endNode.circle.position);
          path.segments[1].point = endNode.circle.getNearestPoint(startNode.circle.position);
          var tree = "tree" in edge ? edge.tree : null;
          var newEdge = addEdge(startNode, endNode, path, edge.properties, tree, false);
          newEdges.push(newEdge);
        });
        context.setErrorMessage(null);
        // context.setLoadingMessage(null);
      } catch (TypeError) {
        context.setErrorMessage("The motif can't import. Please try again in a larger window.");
        // context.setLoadingMessage(null);
        clearSketch();
      }

      // add new edges to edges
      setEdges([].concat(_toConsumableArray(edges), newEdges));
      setEdgeImportUpdate(false);
      setImportData(null);
    }
  }, [edgeImportUpdate]);

  // Checks for edges going opposite to each other and offsets them so they are distinguishable
  (0, _react.useEffect)(function () {
    if (!edges) return;
    edges.forEach(function (e, i) {
      var oppositeEdge = _lodash["default"].findIndex(edges, function (oppE) {
        return _lodash["default"].isEqual(oppE.indices, [e.indices[1], e.indices[0]]);
      });
      if (oppositeEdge !== -1 && !e.oppositeEdge && oppositeEdge > i) {
        var midpoint = new _paper["default"].Point([(e.toPoint.x + e.fromPoint.x) / 2, (e.toPoint.y + e.fromPoint.y) / 2]);
        var circle1 = new _paper["default"].Path.Circle(midpoint, 5);
        var circle2 = new _paper["default"].Path.Circle(circle1.getIntersections(edges[oppositeEdge].edgeLine)[0].point, Math.sqrt(Math.pow(5, 2) + Math.pow(5, 2)));
        var pointDelta = circle2.getIntersections(circle1).map(function (e) {
          return e.point;
        }).sort(function (a, b) {
          return a.y - b.y;
        }).map(function (pt) {
          return new _paper["default"].Point([midpoint.x - pt.x, midpoint.y - pt.y]);
        });
        e["lineGroup"].translate(pointDelta[0]);
        edges[oppositeEdge]["lineGroup"].translate(pointDelta[1]);
        edges[oppositeEdge]["oppositeEdge"] = i;
        e["oppositeEdge"] = oppositeEdge;
      }
      if (e.properties === undefined && e.propertyLabel) {
        e.propertyLabel.content = "";
      }
    });
  }, [edges]);
  (0, _react.useEffect)(function () {
    if (pencil && mouseState) {
      // Rebind the pencil events whenever new nodes are drawn
      bindPencilEvents();
    }
  }, [pencil, mouseState, nodes, edges]);
  (0, _react.useEffect)(function () {
    var _currentPath3, _paper$project2;
    (_currentPath3 = currentPath) === null || _currentPath3 === void 0 || _currentPath3.remove();
    setPopperLocation(null);
    setShowPopper(false);
    if (_paper["default"] !== null && _paper["default"] !== void 0 && (_paper$project2 = _paper["default"].project) !== null && _paper$project2 !== void 0 && _paper$project2.activeLayer) {
      _paper["default"].project.activeLayer.selected = false;
      // Remove all undrawn shapes when you switch modes
      _paper["default"].project.activeLayer.children.forEach(function (child) {
        if (child.opacity === 0.5) child.remove();
      });
    }
  }, [mouseState]);
  (0, _react.useEffect)(function () {
    // if context.selectedSketchElement is not null
    if (context.selectedSketchElement) {
      var _context$selectedSket2, _context$selectedSket3;
      var paperElement = ((_context$selectedSket2 = context.selectedSketchElement) === null || _context$selectedSket2 === void 0 ? void 0 : _context$selectedSket2.circle) || (context === null || context === void 0 || (_context$selectedSket3 = context.selectedSketchElement) === null || _context$selectedSket3 === void 0 ? void 0 : _context$selectedSket3.edgeLine);
      // Calculate where on screen coordinates the popper should go
      var position = paperElement.getPosition();
      var boundingRect = _paper["default"].view.element.getBoundingClientRect();
      if (paperElement && position) {
        setPopperLocation({
          top: position.y + boundingRect.top + 30,
          left: position.x + boundingRect.left - 30
        });
      }
      if (context.selectedSketchElement.type === "edge") {
        setEdges(edges.map(function (e) {
          // Update the edge with the query properties
          if (_lodash["default"].isEqual(e.edgeLine, context.selectedSketchElement.edgeLine)) {
            e.tree = context.selectedSketchElement.tree;
            e.properties = context.selectedSketchElement.properties;
            e = addEdgePropertyLabel(e);
          }
          if (e.fromNode.label === context.selectedSketchElement.fromNode.label && e.toNode.label === context.selectedSketchElement.toNode.label) {
            e.edgeLine.strokeColor = "red";
            e.lineGroup.children[0].strokeColor = "red";
          } else {
            e.edgeLine.strokeColor = "#000000";
            e.lineGroup.children[0].strokeColor = "#000000";
          }
          return e;
        }));
      } else {
        setNodes(nodes.map(function (n) {
          if (_lodash["default"].isEqual(n.circle, context.selectedSketchElement.circle)) {
            // Update the node with the query properties
            n.tree = context.selectedSketchElement.tree;
            n.properties = context.selectedSketchElement.properties;
          }
          return n;
        }));
      }
    } else {
      setPopperLocation(null);
      setEdges(edges.map(function (e) {
        e.edgeLine.strokeColor = "#000000";
        e.lineGroup.children[0].strokeColor = "#000000";
        return e;
      }));
    }
  }, [context.selectedSketchElement]);

  // On init set up our paperjs
  (0, _react.useEffect)(function () {
    _paper["default"].setup(sketchPanelId);
    _paper["default"].view.onResize = function () {
      setCanvasDimension(_paper["default"].view.size);
    };
    setCanvasDimension(_paper["default"].view.size);
    var tempCircle = new _paper["default"].Path.Circle([0, 0], 6);
    tempCircle.fill = "none";
    tempCircle.strokeWidth = 0;
    setTestCircle(tempCircle);
    var tool = new _paper["default"].Tool();
    if (!pencil) {
      setPencil(tool);
    }
    // fetch Node and Edge Fields
    if (!NodeFields || !EdgeFields) {
      if (typeof attributes !== "undefined") {
        setNodeFields(attributes.NodeFields);
        setEdgeFields(attributes.EdgeFields);
      }
    }
    if (nodes.length > 0) {
      var newNodes = _toConsumableArray(nodes);
      setNodes([]);
      newNodes.map(function (node) {
        placeCircle(node.circle, node.label, node.properties, node.tree);
      });
    }
    if (edges.length > 0) {
      var newEdges = _toConsumableArray(edges);
      addExistEdges(newEdges);
    }
    return function () {
      // cleanup component once destroyed
      tool.remove();
      tool.off("mousemove");
      tool.off("mousedown");
      tool.off("mouseup");
    };
  }, []);
  var getEncodedMotif = function getEncodedMotif(nodes, edges) {
    var encodedNodes = nodes.map(function (n, i) {
      return {
        label: n.label,
        properties: n.properties,
        index: i,
        position: n.circle.position,
        tree: n.tree
      };
    });
    var encodedEdges = edges.map(function (e, i) {
      return {
        label: e.label,
        properties: e.properties,
        index: i,
        indices: e.indices,
        tree: e.tree
      };
    });
    var sketchPanelDim = {
      width: canvasDimension.width,
      height: canvasDimension.height
    };
    return {
      nodes: encodedNodes,
      edges: encodedEdges,
      dimension: sketchPanelDim
    };
  };
  // Encode the Nodes and Edges For Query
  (0, _react.useEffect)(function () {
    var encodedMotif = getEncodedMotif(nodes, edges);
    context.setMotifQuery(encodedMotif);

    // most motif queries fail for n larger than 4, develop heuristics to make more accurate
    // nodes.length > 4
    //   ? context.setShowWarning(true)
    //   : context.setShowWarning(false);
    // if (
    //   typeof attributes != "undefined" &&
    //   attributes.getMotifCount &&
    //   attributes.getRelativeMotifCount
    // ) {
    //   const count = await attributes.getMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setAbsMotifCount(count);

    //   // get relative count of motif in network
    //   const relative_count = await attributes.getRelativeMotifCount(
    //     JSON.stringify(encodedMotif)
    //   );
    //   context.setRelativeMotifCount(relative_count);
    // }
  }, [nodes, edges]);
  var isObject = function isObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
  };
  var parsePropertyText = function parsePropertyText(key, value) {
    var parsedValue = "";
    if (isObject(value)) {
      if (value["$ne"]) {
        parsedValue = "Not ".concat(value["$ne"]);
      } else if (value["$lt"]) {
        parsedValue = "< " + value["$lt"];
      } else if (value["$gt"]) {
        parsedValue = "> " + value["$gt"];
      }
    } else {
      parsedValue = value;
    }
    return "".concat(key, ": ").concat(parsedValue, "\n");
  };
  (0, _react.useEffect)(function () {
    if (!nodes) return;
    nodeLabels.forEach(function (label) {
      label === null || label === void 0 || label.remove();
    });
    setNodeLabels(nodes.map(function (n) {
      if (!showInfo) return null;
      console.log("nodes", n, "show", showInfo);
      var propertiesText = _lodash["default"].entries(n === null || n === void 0 ? void 0 : n.properties).map(function (p) {
        return parsePropertyText(p[0], p[1]);
      });
      var labelPoint = [n.circle.position.x, n.circle.position.y - circleRadius - 10 * propertiesText.length];
      var label = new _paper["default"].PointText({
        point: labelPoint,
        justification: "center",
        fillColor: "black",
        font: "Roboto",
        fontSize: 10
      });
      label.content = propertiesText.join("");
      return label;
    }));
  }, [nodes, showInfo, edges]);
  return /*#__PURE__*/_react["default"].createElement("div", {
    className: "sketch-panel-style"
  }, /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    container: true,
    className: "canvas-wrapper",
    spacing: 0
  }, /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Draw Node",
    placement: "right"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "node",
    color: mouseState === "node" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath4;
      (_currentPath4 = currentPath) === null || _currentPath4 === void 0 || _currentPath4.remove();
      setCursor("crosshair");
      setMouseState("node");
    }
  }, /*#__PURE__*/_react["default"].createElement(_CircleTwoTone["default"], {
    fontSize: "small"
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Draw Edge",
    placement: "right"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    color: mouseState === "edge" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath5;
      (_currentPath5 = currentPath) === null || _currentPath5 === void 0 || _currentPath5.remove();
      setCursor("crosshair");
      setMouseState("edge");
    }
  }, /*#__PURE__*/_react["default"].createElement(_ArrowRightAlt["default"], {
    fontSize: "small"
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Edit Properties",
    placement: "right"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "edit" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath6;
      setCursor("pointer");
      (_currentPath6 = currentPath) === null || _currentPath6 === void 0 || _currentPath6.remove();
      setMouseState("edit");
    }
  }, /*#__PURE__*/_react["default"].createElement(_Edit["default"], {
    fontSize: "small"
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Move",
    placement: "right"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "edit",
    color: mouseState === "move" ? "primary" : "default",
    onClick: function onClick() {
      var _currentPath7;
      setCursor("grab");
      (_currentPath7 = currentPath) === null || _currentPath7 === void 0 || _currentPath7.remove();
      setMouseState("move");
    }
  }, /*#__PURE__*/_react["default"].createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faHand
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Node Info",
    placement: "right"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "node",
    color: showInfo ? "primary" : "default",
    onClick: function onClick() {
      setShowInfo(!showInfo);
    }
  }, /*#__PURE__*/_react["default"].createElement(_Info["default"], {
    fontSize: "small"
  }))))), /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    item: true,
    xs: 9.2,
    style: {
      height: "inherit"
    }
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: "sketch-canvas",
    id: "sketch-canvas-container",
    style: {
      cursor: cursor || "crosshair"
    }
  }, /*#__PURE__*/_react["default"].createElement("canvas", {
    id: sketchPanelId,
    resize: "true"
  }), showPopper && popperLocation && context.selectedSketchElement && /*#__PURE__*/_react["default"].createElement(_material.Popover, {
    anchorReference: "anchorPosition",
    open: true,
    hideBackdrop: true,
    className: "sketch-popover",
    disableEnforceFocus: true,
    anchorPosition: popperLocation,
    anchorOrigin: {
      vertical: "top",
      horizontal: "left"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "left"
    }
  }, /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-start",
    style: {
      position: "absolute",
      height: "40.75px"
    }
  }, /*#__PURE__*/_react["default"].createElement("span", {
    style: {
      paddingLeft: 10,
      fontWeight: "bold",
      color: "#454545"
    }
  }, _lodash["default"].capitalize(context.selectedSketchElement.type), " ", context.selectedSketchElement.label)), /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    container: true,
    className: "popover-grid",
    direction: "column",
    justifyContent: "center",
    alignItems: "flex-end",
    style: {
      position: "absolute",
      height: "40.75px",
      right: "110px"
    },
    zIndex: 3
  }, /*#__PURE__*/_react["default"].createElement(_material.Button, {
    size: "small",
    startIcon: /*#__PURE__*/_react["default"].createElement(_Delete["default"], null),
    onClick: function onClick() {
      return deleteSketchElement();
    }
  }, "Delete")), typeof attributes != "undefined" ? /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, attributes.NodeFields || attributes.EdgeFields ? /*#__PURE__*/_react["default"].createElement(_QueryBuilder["default"], {
    NodeFields: attributes.NodeFields ? attributes.NodeFields : {},
    EdgeFields: attributes.EdgeFields ? attributes.EdgeFields : {}
  }) :
  /*#__PURE__*/
  // loading
  _react["default"].createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  }, /*#__PURE__*/_react["default"].createElement(_material.CircularProgress, {
    size: "1.5rem",
    style: {
      marginTop: "30px"
    }
  }))) :
  /*#__PURE__*/
  // general case
  _react["default"].createElement("div", {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "70px",
      width: "290px"
    }
  })))), /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    item: true,
    xs: 1.4
  }, /*#__PURE__*/_react["default"].createElement(_material.Grid, {
    container: true,
    direction: "column",
    justifyContent: "center"
  }, /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Clear Sketch",
    placement: "left"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    color: "default",
    onClick: function onClick() {
      setCursor("crosshair");
      clearSketch();
    }
  }, /*#__PURE__*/_react["default"].createElement(_Delete["default"], {
    fontSize: "small"
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Import Motif",
    placement: "left"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: function onClick() {
      return importMotif();
    }
  }, /*#__PURE__*/_react["default"].createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileImport
  }))), /*#__PURE__*/_react["default"].createElement(_material.Tooltip, {
    title: "Export Motif",
    placement: "left"
  }, /*#__PURE__*/_react["default"].createElement(_material.IconButton, {
    value: "edit",
    color: "default",
    onClick: function onClick() {
      return exportMotif();
    }
  }, /*#__PURE__*/_react["default"].createElement(_reactFontawesome.FontAwesomeIcon, {
    size: "sm",
    icon: _freeSolidSvgIcons.faFileExport,
    style: {
      marginLeft: "0.6em"
    }
  })))))));
}
var _default = exports["default"] = SketchPanel;